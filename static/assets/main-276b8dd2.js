var qa=Object.defineProperty;var $a=(dt,wt,qt)=>wt in dt?qa(dt,wt,{enumerable:!0,configurable:!0,writable:!0,value:qt}):dt[wt]=qt;var qe=(dt,wt,qt)=>($a(dt,typeof wt!="symbol"?wt+"":wt,qt),qt);(function(){"use strict";var dt=(n=>(n[n.config=0]="config",n[n.connect=1]="connect",n[n.requestChunks=2]="requestChunks",n[n.textureLoaded=3]="textureLoaded",n[n.returnGeometryArrays=4]="returnGeometryArrays",n[n.centerPos=5]="centerPos",n))(dt||{}),wt=(n=>(n[n.stateReady=0]="stateReady",n[n.loadTexture=1]="loadTexture",n[n.worldGeometry=2]="worldGeometry",n))(wt||{});function qt(){function n(e,s,i){const r=[];for(const o in e){const a=e[o],h=s[a],u=i[o];r.push({x:u.x,y:u.y,z:u.z,type:h.type,color:h.mapColor,tintColor:h.tintColor,isLiquid:h.isLiquid,isAir:h.isAir,isOccluding:h.isOccluding})}return r}function t(e,s,i){const r=[];for(let o=0;o<i.size;++o)for(let a=0;a<i.size;++a)for(let h=0;h<i.size;++h){const u=o*i.size*i.size+a*i.size+h,c=e[u],l=s[c];r.push({x:i.x+o,y:i.y+a,z:i.z+h,type:l.type,color:l.mapColor,tintColor:l.tintColor,isLiquid:l.isLiquid,isAir:l.isAir,isOccluding:l.isOccluding})}return r}return{parseBlocks:n,parseChunk:t}}var Gn=(n=>(n.Main="main",n.Worker="worker",n))(Gn||{}),Ys=(n=>(n.Connect="connect",n.Login="login",n.GetEntity="getEntity",n.GetNearbyEntities="getNearbyEntities",n.GetChunks="getChunks",n))(Ys||{}),os=(n=>(n.Connected="connected",n.Error="error",n.Blocks="blocks",n.Chunks="chunks",n.Entity="entity",n.NearbyEntities="nearbyEntities",n.EntityMoved="entityMoved",n.Entities="entities",n.ChatMessage="chatMessage",n))(os||{});class wr{static parse(t){const e=JSON.parse(t);return{type:e.type,data:e.data}}}function br(n,t){const e=new Set(n.split(","));return t?s=>e.has(s.toLowerCase()):s=>e.has(s)}const Rt=Object.freeze({}),as=()=>{},Bt=Object.assign,zr=Object.prototype.hasOwnProperty,J=(n,t)=>zr.call(n,t),et=Array.isArray,me=n=>cs(n)==="[object Map]",Mr=n=>cs(n)==="[object Set]",st=n=>typeof n=="function",Xs=n=>typeof n=="string",hs=n=>typeof n=="symbol",vt=n=>n!==null&&typeof n=="object",Ar=n=>(vt(n)||st(n))&&st(n.then)&&st(n.catch),Sr=Object.prototype.toString,cs=n=>Sr.call(n),Dn=n=>cs(n).slice(8,-1),vr=n=>cs(n)==="[object Object]",Vs=n=>Xs(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,Cr=(n=>{const t=Object.create(null);return e=>t[e]||(t[e]=n(e))})(n=>n.charAt(0).toUpperCase()+n.slice(1)),$t=(n,t)=>!Object.is(n,t),Er=(n,t,e)=>{Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value:e})};let Yn;const Xn=()=>Yn||(Yn=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Vn(n,...t){console.warn(`[Vue warn] ${n}`,...t)}let Ir;function Rr(n,t=Ir){t&&t.active&&t.effects.push(n)}let ie;class Hn{constructor(t,e,s,i){this.fn=t,this.trigger=e,this.scheduler=s,this.active=!0,this.deps=[],this._dirtyLevel=3,this._trackId=0,this._runnings=0,this._queryings=0,this._depsLength=0,Rr(this,i)}get dirty(){if(this._dirtyLevel===1){this._dirtyLevel=0,this._queryings++,js();for(const t of this.deps)if(t.computed&&(Br(t.computed),this._dirtyLevel>=2))break;Zs(),this._queryings--}return this._dirtyLevel>=2}set dirty(t){this._dirtyLevel=t?3:0}run(){if(this._dirtyLevel=0,!this.active)return this.fn();let t=Gt,e=ie;try{return Gt=!0,ie=this,this._runnings++,jn(this),this.fn()}finally{Zn(this),this._runnings--,ie=e,Gt=t}}stop(){var t;this.active&&(jn(this),Zn(this),(t=this.onStop)==null||t.call(this),this.active=!1)}}function Br(n){return n.value}function jn(n){n._trackId++,n._depsLength=0}function Zn(n){if(n.deps&&n.deps.length>n._depsLength){for(let t=n._depsLength;t<n.deps.length;t++)Jn(n.deps[t],n);n.deps.length=n._depsLength}}function Jn(n,t){const e=n.get(t);e!==void 0&&t._trackId!==e&&(n.delete(t),n.size===0&&n.cleanup())}let Gt=!0,Hs=0;const Kn=[];function js(){Kn.push(Gt),Gt=!1}function Zs(){const n=Kn.pop();Gt=n===void 0?!0:n}function Js(){Hs++}function Ks(){for(Hs--;!Hs&&Qs.length;)Qs.shift()()}function Qn(n,t,e){var s;if(t.get(n)!==n._trackId){t.set(n,n._trackId);const i=n.deps[n._depsLength];i!==t?(i&&Jn(i,n),n.deps[n._depsLength++]=t):n._depsLength++,(s=n.onTrack)==null||s.call(n,Bt({effect:n},e))}}const Qs=[];function ti(n,t,e){var s;Js();for(const i of n.keys())if(!(!i.allowRecurse&&i._runnings)&&i._dirtyLevel<t&&(!i._runnings||t!==2)){const r=i._dirtyLevel;i._dirtyLevel=t,r===0&&(!i._queryings||t!==2)&&((s=i.onTrigger)==null||s.call(i,Bt({effect:i},e)),i.trigger(),i.scheduler&&Qs.push(i.scheduler))}Ks()}const ei=(n,t)=>{const e=new Map;return e.cleanup=n,e.computed=t,e},tn=new WeakMap,re=Symbol("iterate"),en=Symbol("Map key iterate");function ft(n,t,e){if(Gt&&ie){let s=tn.get(n);s||tn.set(n,s=new Map);let i=s.get(e);i||s.set(e,i=ei(()=>s.delete(e))),Qn(ie,i,{target:n,type:t,key:e})}}function Dt(n,t,e,s,i,r){const o=tn.get(n);if(!o)return;let a=[];if(t==="clear")a=[...o.values()];else if(e==="length"&&et(n)){const h=Number(s);o.forEach((u,c)=>{(c==="length"||!hs(c)&&c>=h)&&a.push(u)})}else switch(e!==void 0&&a.push(o.get(e)),t){case"add":et(n)?Vs(e)&&a.push(o.get("length")):(a.push(o.get(re)),me(n)&&a.push(o.get(en)));break;case"delete":et(n)||(a.push(o.get(re)),me(n)&&a.push(o.get(en)));break;case"set":me(n)&&a.push(o.get(re));break}Js();for(const h of a)h&&ti(h,3,{target:n,type:t,key:e,newValue:s,oldValue:i,oldTarget:r});Ks()}const Tr=br("__proto__,__v_isRef,__isVue"),si=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(hs)),ni=kr();function kr(){const n={};return["includes","indexOf","lastIndexOf"].forEach(t=>{n[t]=function(...e){const s=q(this);for(let r=0,o=this.length;r<o;r++)ft(s,"get",r+"");const i=s[t](...e);return i===-1||i===!1?s[t](...e.map(q)):i}}),["push","pop","shift","unshift","splice"].forEach(t=>{n[t]=function(...e){js(),Js();const s=q(this)[t].apply(this,e);return Ks(),Zs(),s}}),n}function Pr(n){const t=q(this);return ft(t,"has",n),t.hasOwnProperty(n)}class ii{constructor(t=!1,e=!1){this._isReadonly=t,this._shallow=e}get(t,e,s){const i=this._isReadonly,r=this._shallow;if(e==="__v_isReactive")return!i;if(e==="__v_isReadonly")return i;if(e==="__v_isShallow")return r;if(e==="__v_raw")return s===(i?r?fi:di:r?Vr:li).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const o=et(t);if(!i){if(o&&J(ni,e))return Reflect.get(ni,e,s);if(e==="hasOwnProperty")return Pr}const a=Reflect.get(t,e,s);return(hs(e)?si.has(e):Tr(e))||(i||ft(t,"get",e),r)?a:bt(a)?o&&Vs(e)?a:a.value:vt(a)?i?mi(a):pi(a):a}}class Or extends ii{constructor(t=!1){super(!1,t)}set(t,e,s,i){let r=t[e];if(!this._shallow){const h=oe(r);if(!xs(s)&&!oe(s)&&(r=q(r),s=q(s)),!et(t)&&bt(r)&&!bt(s))return h?!1:(r.value=s,!0)}const o=et(t)&&Vs(e)?Number(e)<t.length:J(t,e),a=Reflect.set(t,e,s,i);return t===q(i)&&(o?$t(s,r)&&Dt(t,"set",e,s,r):Dt(t,"add",e,s)),a}deleteProperty(t,e){const s=J(t,e),i=t[e],r=Reflect.deleteProperty(t,e);return r&&s&&Dt(t,"delete",e,void 0,i),r}has(t,e){const s=Reflect.has(t,e);return(!hs(e)||!si.has(e))&&ft(t,"has",e),s}ownKeys(t){return ft(t,"iterate",et(t)?"length":re),Reflect.ownKeys(t)}}class ri extends ii{constructor(t=!1){super(!0,t)}set(t,e){return Vn(`Set operation on key "${String(e)}" failed: target is readonly.`,t),!0}deleteProperty(t,e){return Vn(`Delete operation on key "${String(e)}" failed: target is readonly.`,t),!0}}const Fr=new Or,Wr=new ri,Ur=new ri(!0),sn=n=>n,us=n=>Reflect.getPrototypeOf(n);function ls(n,t,e=!1,s=!1){n=n.__v_raw;const i=q(n),r=q(t);e||($t(t,r)&&ft(i,"get",t),ft(i,"get",r));const{has:o}=us(i),a=s?sn:e?on:$e;if(o.call(i,t))return a(n.get(t));if(o.call(i,r))return a(n.get(r));n!==i&&n.get(t)}function ds(n,t=!1){const e=this.__v_raw,s=q(e),i=q(n);return t||($t(n,i)&&ft(s,"has",n),ft(s,"has",i)),n===i?e.has(n):e.has(n)||e.has(i)}function fs(n,t=!1){return n=n.__v_raw,!t&&ft(q(n),"iterate",re),Reflect.get(n,"size",n)}function oi(n){n=q(n);const t=q(this);return us(t).has.call(t,n)||(t.add(n),Dt(t,"add",n,n)),this}function ai(n,t){t=q(t);const e=q(this),{has:s,get:i}=us(e);let r=s.call(e,n);r?ui(e,s,n):(n=q(n),r=s.call(e,n));const o=i.call(e,n);return e.set(n,t),r?$t(t,o)&&Dt(e,"set",n,t,o):Dt(e,"add",n,t),this}function hi(n){const t=q(this),{has:e,get:s}=us(t);let i=e.call(t,n);i?ui(t,e,n):(n=q(n),i=e.call(t,n));const r=s?s.call(t,n):void 0,o=t.delete(n);return i&&Dt(t,"delete",n,void 0,r),o}function ci(){const n=q(this),t=n.size!==0,e=me(n)?new Map(n):new Set(n),s=n.clear();return t&&Dt(n,"clear",void 0,void 0,e),s}function ps(n,t){return function(s,i){const r=this,o=r.__v_raw,a=q(o),h=t?sn:n?on:$e;return!n&&ft(a,"iterate",re),o.forEach((u,c)=>s.call(i,h(u),h(c),r))}}function ms(n,t,e){return function(...s){const i=this.__v_raw,r=q(i),o=me(r),a=n==="entries"||n===Symbol.iterator&&o,h=n==="keys"&&o,u=i[n](...s),c=e?sn:t?on:$e;return!t&&ft(r,"iterate",h?en:re),{next(){const{value:l,done:d}=u.next();return d?{value:l,done:d}:{value:a?[c(l[0]),c(l[1])]:c(l),done:d}},[Symbol.iterator](){return this}}}}function Yt(n){return function(...t){{const e=t[0]?`on key "${t[0]}" `:"";console.warn(`${Cr(n)} operation ${e}failed: target is readonly.`,q(this))}return n==="delete"?!1:n==="clear"?void 0:this}}function Lr(){const n={get(r){return ls(this,r)},get size(){return fs(this)},has:ds,add:oi,set:ai,delete:hi,clear:ci,forEach:ps(!1,!1)},t={get(r){return ls(this,r,!1,!0)},get size(){return fs(this)},has:ds,add:oi,set:ai,delete:hi,clear:ci,forEach:ps(!1,!0)},e={get(r){return ls(this,r,!0)},get size(){return fs(this,!0)},has(r){return ds.call(this,r,!0)},add:Yt("add"),set:Yt("set"),delete:Yt("delete"),clear:Yt("clear"),forEach:ps(!0,!1)},s={get(r){return ls(this,r,!0,!0)},get size(){return fs(this,!0)},has(r){return ds.call(this,r,!0)},add:Yt("add"),set:Yt("set"),delete:Yt("delete"),clear:Yt("clear"),forEach:ps(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=ms(r,!1,!1),e[r]=ms(r,!0,!1),t[r]=ms(r,!1,!0),s[r]=ms(r,!0,!0)}),[n,e,t,s]}const[Nr,qr,$r,Gr]=Lr();function nn(n,t){const e=t?n?Gr:$r:n?qr:Nr;return(s,i,r)=>i==="__v_isReactive"?!n:i==="__v_isReadonly"?n:i==="__v_raw"?s:Reflect.get(J(e,i)&&i in s?e:s,i,r)}const Dr={get:nn(!1,!1)},Yr={get:nn(!0,!1)},Xr={get:nn(!0,!0)};function ui(n,t,e){const s=q(e);if(s!==e&&t.call(n,s)){const i=Dn(n);console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const li=new WeakMap,Vr=new WeakMap,di=new WeakMap,fi=new WeakMap;function Hr(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function jr(n){return n.__v_skip||!Object.isExtensible(n)?0:Hr(Dn(n))}function pi(n){return oe(n)?n:rn(n,!1,Fr,Dr,li)}function mi(n){return rn(n,!0,Wr,Yr,di)}function ys(n){return rn(n,!0,Ur,Xr,fi)}function rn(n,t,e,s,i){if(!vt(n))return console.warn(`value cannot be made reactive: ${String(n)}`),n;if(n.__v_raw&&!(t&&n.__v_isReactive))return n;const r=i.get(n);if(r)return r;const o=jr(n);if(o===0)return n;const a=new Proxy(n,o===2?s:e);return i.set(n,a),a}function ye(n){return oe(n)?ye(n.__v_raw):!!(n&&n.__v_isReactive)}function oe(n){return!!(n&&n.__v_isReadonly)}function xs(n){return!!(n&&n.__v_isShallow)}function q(n){const t=n&&n.__v_raw;return t?q(t):n}function Zr(n){return Er(n,"__v_skip",!0),n}const $e=n=>vt(n)?pi(n):n,on=n=>vt(n)?mi(n):n;class yi{constructor(t,e,s,i){this._setter=e,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this.effect=new Hn(()=>t(this._value),()=>an(this,1)),this.effect.computed=this,this.effect.active=this._cacheable=!i,this.__v_isReadonly=s}get value(){const t=q(this);return xi(t),(!t._cacheable||t.effect.dirty)&&$t(t._value,t._value=t.effect.run())&&an(t,2),t._value}set value(t){this._setter(t)}get _dirty(){return this.effect.dirty}set _dirty(t){this.effect.dirty=t}}function Jr(n,t,e=!1){let s,i;const r=st(n);r?(s=n,i=()=>{console.warn("Write operation failed: computed value is readonly")}):(s=n.get,i=n.set);const o=new yi(s,i,r||!i,e);return t&&!e&&(o.effect.onTrack=t.onTrack,o.effect.onTrigger=t.onTrigger),o}function xi(n){Gt&&ie&&(n=q(n),Qn(ie,n.dep||(n.dep=ei(()=>n.dep=void 0,n instanceof yi?n:void 0)),{target:n,type:"get",key:"value"}))}function an(n,t=3,e){n=q(n);const s=n.dep;s&&ti(s,t,{target:n,type:"set",key:"value",newValue:e})}function bt(n){return!!(n&&n.__v_isRef===!0)}function nt(n){return _i(n,!1)}function gi(n){return _i(n,!0)}function _i(n,t){return bt(n)?n:new Kr(n,t)}class Kr{constructor(t,e){this.__v_isShallow=e,this.dep=void 0,this.__v_isRef=!0,this._rawValue=e?t:q(t),this._value=e?t:$e(t)}get value(){return xi(this),this._value}set value(t){const e=this.__v_isShallow||xs(t)||oe(t);t=e?t:q(t),$t(t,this._rawValue)&&(this._rawValue=t,this._value=e?t:$e(t),an(this,3,t))}}function Qr(n){return bt(n)?n.value:n}const to={get:(n,t,e)=>Qr(Reflect.get(n,t,e)),set:(n,t,e,s)=>{const i=n[t];return bt(i)&&!bt(e)?(i.value=e,!0):Reflect.set(n,t,e,s)}};function eo(n){return ye(n)?n:new Proxy(n,to)}const ae=[];function so(n){ae.push(n)}function no(){ae.pop()}function ot(n,...t){js();const e=ae.length?ae[ae.length-1].component:null,s=e&&e.appContext.config.warnHandler,i=io();if(s)he(s,e,11,[n+t.join(""),e&&e.proxy,i.map(({vnode:r})=>`at <${Fi(e,r.type)}>`).join(`
`),i]);else{const r=[`[Vue warn]: ${n}`,...t];i.length&&r.push(`
`,...ro(i)),console.warn(...r)}Zs()}function io(){let n=ae[ae.length-1];if(!n)return[];const t=[];for(;n;){const e=t[0];e&&e.vnode===n?e.recurseCount++:t.push({vnode:n,recurseCount:0});const s=n.component&&n.component.parent;n=s&&s.vnode}return t}function ro(n){const t=[];return n.forEach((e,s)=>{t.push(...s===0?[]:[`
`],...oo(e))}),t}function oo({vnode:n,recurseCount:t}){const e=t>0?`... (${t} recursive calls)`:"",s=n.component?n.component.parent==null:!1,i=` at <${Fi(n.component,n.type,s)}`,r=">"+e;return n.props?[i,...ao(n.props),r]:[i+r]}function ao(n){const t=[],e=Object.keys(n);return e.slice(0,3).forEach(s=>{t.push(...wi(s,n[s]))}),e.length>3&&t.push(" ..."),t}function wi(n,t,e){return Xs(t)?(t=JSON.stringify(t),e?t:[`${n}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?e?t:[`${n}=${t}`]:bt(t)?(t=wi(n,q(t.value),!0),e?t:[`${n}=Ref<`,t,">"]):st(t)?[`${n}=fn${t.name?`<${t.name}>`:""}`]:(t=q(t),e?t:[`${n}=`,t])}const bi={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."};function he(n,t,e,s){let i;try{i=s?n(...s):n()}catch(r){hn(r,t,e)}return i}function gs(n,t,e,s){if(st(n)){const r=he(n,t,e,s);return r&&Ar(r)&&r.catch(o=>{hn(o,t,e)}),r}const i=[];for(let r=0;r<n.length;r++)i.push(gs(n[r],t,e,s));return i}function hn(n,t,e,s=!0){const i=t?t.vnode:null;if(t){let r=t.parent;const o=t.proxy,a=bi[e];for(;r;){const u=r.ec;if(u){for(let c=0;c<u.length;c++)if(u[c](n,o,a)===!1)return}r=r.parent}const h=t.appContext.config.errorHandler;if(h){he(h,null,10,[n,o,a]);return}}ho(n,e,i,s)}function ho(n,t,e,s=!0){{const i=bi[t];if(e&&so(e),ot(`Unhandled error${i?` during execution of ${i}`:""}`),e&&no(),s)throw n;console.error(n)}}let _s=!1,cn=!1;const Mt=[];let Xt=0;const xe=[];let Tt=null,Vt=0;const zi=Promise.resolve();let un=null;const co=100;function uo(n){const t=un||zi;return n?t.then(this?n.bind(this):n):t}function lo(n){let t=Xt+1,e=Mt.length;for(;t<e;){const s=t+e>>>1,i=Mt[s],r=Ge(i);r<n||r===n&&i.pre?t=s+1:e=s}return t}function ln(n){(!Mt.length||!Mt.includes(n,_s&&n.allowRecurse?Xt+1:Xt))&&(n.id==null?Mt.push(n):Mt.splice(lo(n.id),0,n),Mi())}function Mi(){!_s&&!cn&&(cn=!0,un=zi.then(Si))}function Ai(n){et(n)?xe.push(...n):(!Tt||!Tt.includes(n,n.allowRecurse?Vt+1:Vt))&&xe.push(n),Mi()}function fo(n){if(xe.length){const t=[...new Set(xe)].sort((e,s)=>Ge(e)-Ge(s));if(xe.length=0,Tt){Tt.push(...t);return}for(Tt=t,n=n||new Map,Vt=0;Vt<Tt.length;Vt++)vi(n,Tt[Vt])||Tt[Vt]();Tt=null,Vt=0}}const Ge=n=>n.id==null?1/0:n.id,po=(n,t)=>{const e=Ge(n)-Ge(t);if(e===0){if(n.pre&&!t.pre)return-1;if(t.pre&&!n.pre)return 1}return e};function Si(n){cn=!1,_s=!0,n=n||new Map,Mt.sort(po);const t=e=>vi(n,e);try{for(Xt=0;Xt<Mt.length;Xt++){const e=Mt[Xt];if(e&&e.active!==!1){if(t(e))continue;he(e,null,14)}}}finally{Xt=0,Mt.length=0,fo(n),_s=!1,un=null,(Mt.length||xe.length)&&Si(n)}}function vi(n,t){if(!n.has(t))n.set(t,1);else{const e=n.get(t);if(e>co){const s=t.ownerInstance,i=s&&Oi(s.type);return hn(`Maximum recursive updates exceeded${i?` in component <${i}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}else n.set(t,e+1)}}const De=new Set;Xn().__VUE_HMR_RUNTIME__={createRecord:dn(mo),rerender:dn(yo),reload:dn(xo)};const ws=new Map;function mo(n,t){return ws.has(n)?!1:(ws.set(n,{initialDef:Ye(t),instances:new Set}),!0)}function Ye(n){return Oo(n)?n.__vccOpts:n}function yo(n,t){const e=ws.get(n);e&&(e.initialDef.render=t,[...e.instances].forEach(s=>{t&&(s.render=t,Ye(s.type).render=t),s.renderCache=[],s.effect.dirty=!0,s.update()}))}function xo(n,t){const e=ws.get(n);if(!e)return;t=Ye(t),Ci(e.initialDef,t);const s=[...e.instances];for(const i of s){const r=Ye(i.type);De.has(r)||(r!==e.initialDef&&Ci(r,t),De.add(r)),i.appContext.propsCache.delete(i.type),i.appContext.emitsCache.delete(i.type),i.appContext.optionsCache.delete(i.type),i.ceReload?(De.add(r),i.ceReload(t.styles),De.delete(r)):i.parent?(i.parent.effect.dirty=!0,ln(i.parent.update)):i.appContext.reload?i.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")}Ai(()=>{for(const i of s)De.delete(Ye(i.type))})}function Ci(n,t){Bt(n,t);for(const e in n)e!=="__file"&&!(e in t)&&delete n[e]}function dn(n){return(t,e)=>{try{return n(t,e)}catch(s){console.error(s),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}let go=null;function _o(n,t){t&&t.pendingBranch?et(n)?t.effects.push(...n):t.effects.push(n):Ai(n)}const wo=Symbol.for("v-scx"),bo=()=>{{const n=Io(wo);return n||ot("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."),n}},bs={};function Ht(n,t,e){return st(t)||ot("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."),Ei(n,t,e)}function Ei(n,t,{immediate:e,deep:s,flush:i,once:r,onTrack:o,onTrigger:a}=Rt){if(t&&r){const _=t;t=(...M)=>{_(...M),g()}}s!==void 0&&typeof s=="number"&&ot('watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.'),t||(e!==void 0&&ot('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'),s!==void 0&&ot('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'),r!==void 0&&ot('watch() "once" option is only respected when using the watch(source, callback, options?) signature.'));const h=_=>{ot("Invalid watch source: ",_,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},u=Ms,c=_=>s===!0?_:ge(_,s===!1?1:void 0);let l,d=!1,p=!1;if(bt(n)?(l=()=>n.value,d=xs(n)):ye(n)?(l=()=>c(n),d=!0):et(n)?(p=!0,d=n.some(_=>ye(_)||xs(_)),l=()=>n.map(_=>{if(bt(_))return _.value;if(ye(_))return c(_);if(st(_))return he(_,u,2);h(_)})):st(n)?t?l=()=>he(n,u,2):l=()=>(f&&f(),gs(n,u,3,[m])):(l=as,h(n)),t&&s){const _=l;l=()=>ge(_())}let f,m=_=>{f=y.onStop=()=>{he(_,u,4),f=y.onStop=void 0}},b;if(yn)if(m=as,t?e&&gs(t,u,3,[l(),p?[]:void 0,m]):l(),i==="sync"){const _=bo();b=_.__watcherHandles||(_.__watcherHandles=[])}else return as;let w=p?new Array(n.length).fill(bs):bs;const S=()=>{if(!(!y.active||!y.dirty))if(t){const _=y.run();(s||d||(p?_.some((M,R)=>$t(M,w[R])):$t(_,w)))&&(f&&f(),gs(t,u,3,[_,w===bs?void 0:p&&w[0]===bs?[]:w,m]),w=_)}else y.run()};S.allowRecurse=!!t;let x;i==="sync"?x=S:i==="post"?x=()=>Pi(S,u&&u.suspense):(S.pre=!0,u&&(S.id=u.uid),x=()=>ln(S));const y=new Hn(l,as,x),g=()=>{y.stop()};return y.onTrack=o,y.onTrigger=a,t?e?S():w=y.run():i==="post"?Pi(y.run.bind(y),u&&u.suspense):y.run(),b&&b.push(g),g}function zo(n,t,e){const s=this.proxy,i=Xs(n)?n.includes(".")?Mo(s,n):()=>s[n]:n.bind(s,s);let r;st(t)?r=t:(r=t.handler,e=t);const o=Ro(this),a=Ei(i,r.bind(s),e);return o(),a}function Mo(n,t){const e=t.split(".");return()=>{let s=n;for(let i=0;i<e.length&&s;i++)s=s[e[i]];return s}}function ge(n,t,e=0,s){if(!vt(n)||n.__v_skip)return n;if(t&&t>0){if(e>=t)return n;e++}if(s=s||new Set,s.has(n))return n;if(s.add(n),bt(n))ge(n.value,t,e,s);else if(et(n))for(let i=0;i<n.length;i++)ge(n[i],t,e,s);else if(Mr(n)||me(n))n.forEach(i=>{ge(i,t,e,s)});else if(vr(n))for(const i in n)ge(n[i],t,e,s);return n}const fn=n=>n?Bo(n)?To(n)||n.proxy:fn(n.parent):null,Xe=Bt(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>ys(n.props),$attrs:n=>ys(n.attrs),$slots:n=>ys(n.slots),$refs:n=>ys(n.refs),$parent:n=>fn(n.parent),$root:n=>fn(n.root),$emit:n=>n.emit,$options:n=>So(n),$forceUpdate:n=>n.f||(n.f=()=>{n.effect.dirty=!0,ln(n.update)}),$nextTick:n=>n.n||(n.n=uo.bind(n.proxy)),$watch:n=>zo.bind(n)}),pn=(n,t)=>n!==Rt&&!n.__isScriptSetup&&J(n,t),Ao={get({_:n},t){const{ctx:e,setupState:s,data:i,props:r,accessCache:o,type:a,appContext:h}=n;if(t==="__isVue")return!0;let u;if(t[0]!=="$"){const p=o[t];if(p!==void 0)switch(p){case 1:return s[t];case 2:return i[t];case 4:return e[t];case 3:return r[t]}else{if(pn(s,t))return o[t]=1,s[t];if(i!==Rt&&J(i,t))return o[t]=2,i[t];if((u=n.propsOptions[0])&&J(u,t))return o[t]=3,r[t];if(e!==Rt&&J(e,t))return o[t]=4,e[t];o[t]=0}}const c=Xe[t];let l,d;if(c)return(t==="$attrs"||t==="$slots")&&ft(n,"get",t),c(n);if((l=a.__cssModules)&&(l=l[t]))return l;if(e!==Rt&&J(e,t))return o[t]=4,e[t];if(d=h.config.globalProperties,J(d,t))return d[t]},set({_:n},t,e){const{data:s,setupState:i,ctx:r}=n;return pn(i,t)?(i[t]=e,!0):i.__isScriptSetup&&J(i,t)?(ot(`Cannot mutate <script setup> binding "${t}" from Options API.`),!1):s!==Rt&&J(s,t)?(s[t]=e,!0):J(n.props,t)?(ot(`Attempting to mutate prop "${t}". Props are readonly.`),!1):t[0]==="$"&&t.slice(1)in n?(ot(`Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`),!1):(t in n.appContext.config.globalProperties?Object.defineProperty(r,t,{enumerable:!0,configurable:!0,value:e}):r[t]=e,!0)},has({_:{data:n,setupState:t,accessCache:e,ctx:s,appContext:i,propsOptions:r}},o){let a;return!!e[o]||n!==Rt&&J(n,o)||pn(t,o)||(a=r[0])&&J(a,o)||J(s,o)||J(Xe,o)||J(i.config.globalProperties,o)},defineProperty(n,t,e){return e.get!=null?n._.accessCache[t]=0:J(e,"value")&&this.set(n,t,e.value,null),Reflect.defineProperty(n,t,e)}};Ao.ownKeys=n=>(ot("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(n));function Ii(n){return et(n)?n.reduce((t,e)=>(t[e]=null,t),{}):n}function So(n){const t=n.type,{mixins:e,extends:s}=t,{mixins:i,optionsCache:r,config:{optionMergeStrategies:o}}=n.appContext,a=r.get(t);let h;return a?h=a:!i.length&&!e&&!s?h=t:(h={},i.length&&i.forEach(u=>zs(h,u,o,!0)),zs(h,t,o)),vt(t)&&r.set(t,h),h}function zs(n,t,e,s=!1){const{mixins:i,extends:r}=t;r&&zs(n,r,e,!0),i&&i.forEach(o=>zs(n,o,e,!0));for(const o in t)if(s&&o==="expose")ot('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const a=vo[o]||e&&e[o];n[o]=a?a(n[o],t[o]):t[o]}return n}const vo={data:Ri,props:Ti,emits:Ti,methods:Ve,computed:Ve,beforeCreate:at,created:at,beforeMount:at,mounted:at,beforeUpdate:at,updated:at,beforeDestroy:at,beforeUnmount:at,destroyed:at,unmounted:at,activated:at,deactivated:at,errorCaptured:at,serverPrefetch:at,components:Ve,directives:Ve,watch:Eo,provide:Ri,inject:Co};function Ri(n,t){return t?n?function(){return Bt(st(n)?n.call(this,this):n,st(t)?t.call(this,this):t)}:t:n}function Co(n,t){return Ve(Bi(n),Bi(t))}function Bi(n){if(et(n)){const t={};for(let e=0;e<n.length;e++)t[n[e]]=n[e];return t}return n}function at(n,t){return n?[...new Set([].concat(n,t))]:t}function Ve(n,t){return n?Bt(Object.create(null),n,t):t}function Ti(n,t){return n?et(n)&&et(t)?[...new Set([...n,...t])]:Bt(Object.create(null),Ii(n),Ii(t??{})):t}function Eo(n,t){if(!n)return t;if(!t)return n;const e=Bt(Object.create(null),n);for(const s in t)e[s]=at(n[s],t[s]);return e}let ki=null;function Io(n,t,e=!1){const s=Ms||go;if(s||ki){const i=s?s.parent==null?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:ki._context.provides;if(i&&n in i)return i[n];if(arguments.length>1)return e&&st(t)?t.call(s&&s.proxy):t;ot(`injection "${String(n)}" not found.`)}else ot("inject() can only be used inside setup() or functional components.")}const Pi=_o;let Ms=null,mn;{const n=Xn(),t=(e,s)=>{let i;return(i=n[e])||(i=n[e]=[]),i.push(s),r=>{i.length>1?i.forEach(o=>o(r)):i[0](r)}};mn=t("__VUE_INSTANCE_SETTERS__",e=>Ms=e),t("__VUE_SSR_SETTERS__",e=>yn=e)}const Ro=n=>{const t=Ms;return mn(n),n.scope.on(),()=>{n.scope.off(),mn(t)}};function Bo(n){return n.vnode.shapeFlag&4}let yn=!1;function To(n){if(n.exposed)return n.exposeProxy||(n.exposeProxy=new Proxy(eo(Zr(n.exposed)),{get(t,e){if(e in t)return t[e];if(e in Xe)return Xe[e](n)},has(t,e){return e in t||e in Xe}}))}const ko=/(?:^|[-_])(\w)/g,Po=n=>n.replace(ko,t=>t.toUpperCase()).replace(/[-_]/g,"");function Oi(n,t=!0){return st(n)?n.displayName||n.name:n.name||t&&n.__name}function Fi(n,t,e=!1){let s=Oi(t);if(!s&&t.__file){const i=t.__file.match(/([^/\\]+)\.\w+$/);i&&(s=i[1])}if(!s&&n&&n.parent){const i=r=>{for(const o in r)if(r[o]===t)return o};s=i(n.components||n.parent.type.components)||i(n.appContext.components)}return s?Po(s):e?"App":"Anonymous"}function Oo(n){return st(n)&&"__vccOpts"in n}const xn=(n,t)=>Jr(n,t,yn);function gn(n){return!!(n&&n.__v_isShallow)}function Fo(){if(typeof window>"u")return;const n={style:"color:#3ba776"},t={style:"color:#1677ff"},e={style:"color:#f5222d"},s={style:"color:#eb2f96"},i={header(l){return vt(l)?l.__isVue?["div",n,"VueInstance"]:bt(l)?["div",{},["span",n,c(l)],"<",a(l.value),">"]:ye(l)?["div",{},["span",n,gn(l)?"ShallowReactive":"Reactive"],"<",a(l),`>${oe(l)?" (readonly)":""}`]:oe(l)?["div",{},["span",n,gn(l)?"ShallowReadonly":"Readonly"],"<",a(l),">"]:null:null},hasBody(l){return l&&l.__isVue},body(l){if(l&&l.__isVue)return["div",{},...r(l.$)]}};function r(l){const d=[];l.type.props&&l.props&&d.push(o("props",q(l.props))),l.setupState!==Rt&&d.push(o("setup",l.setupState)),l.data!==Rt&&d.push(o("data",q(l.data)));const p=h(l,"computed");p&&d.push(o("computed",p));const f=h(l,"inject");return f&&d.push(o("injected",f)),d.push(["div",{},["span",{style:s.style+";opacity:0.66"},"$ (internal): "],["object",{object:l}]]),d}function o(l,d){return d=Bt({},d),Object.keys(d).length?["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},l],["div",{style:"padding-left:1.25em"},...Object.keys(d).map(p=>["div",{},["span",s,p+": "],a(d[p],!1)])]]:["span",{}]}function a(l,d=!0){return typeof l=="number"?["span",t,l]:typeof l=="string"?["span",e,JSON.stringify(l)]:typeof l=="boolean"?["span",s,l]:vt(l)?["object",{object:d?q(l):l}]:["span",e,String(l)]}function h(l,d){const p=l.type;if(st(p))return;const f={};for(const m in l.ctx)u(p,m,d)&&(f[m]=l.ctx[m]);return f}function u(l,d,p){const f=l[p];if(et(f)&&f.includes(d)||vt(f)&&d in f||l.extends&&u(l.extends,d,p)||l.mixins&&l.mixins.some(m=>u(m,d,p)))return!0}function c(l){return gn(l)?"ShallowRef":l.effect?"ComputedRef":"Ref"}window.devtoolsFormatters?window.devtoolsFormatters.push(i):window.devtoolsFormatters=[i]}function Wo(){Fo()}Wo();const Wi=nt(),Ui=nt(),Li=nt(),Ni=nt(),qi=nt();function _n(){function n(e,s,i=!1,r,o){console.log("ssl=",i),console.log("entity_id=",o);const h=`${i==!0?"wss://":"ws://"}${e}:${s}/ws`,u=Wi.value=new WebSocket(h);u.onopen=function(c){Ui.value=c},u.onmessage=function(c){const l=wr.parse(c.data);Ni.value=l},u.onclose=function(c){Li.value=c}}function t(e){var s;qi.value=e,(s=Wi.value)==null||s.send(JSON.stringify(e))}return{connect:n,send:t,onOpen:Ui,onClose:Li,onReceive:Ni,onSend:qi}}var $i=(n=>(n[n.init=0]="init",n[n.connecting=1]="connecting",n[n.connected=2]="connected",n[n.disconnected=3]="disconnected",n))($i||{});const Gi=nt(""),Di=nt(""),As=nt(0),Yi=nt([]),Xi=nt([{chunk:{x:0,y:0,z:0,size:0},blocks:[]}]);function Ss(){function n(o,a,h,u,c){Gi.value=u,Di.value=c;const{connect:l,onOpen:d,onClose:p,onReceive:f,onSend:m}=_n();l(o,a,h,u,c),Ht(d,t),Ht(p,e),Ht(f,i),Ht(m,s)}function t(){As.value=1;const o={type:Ys.Connect,data:{clientType:Gn.Worker,player:Gi.value,entity:Di.value}},{send:a}=_n();a(o)}function e(){As.value=3}function s(o){}function i(o){if(o)switch(o.type){case os.Connected:As.value=2;break;case os.Blocks:{const a=o.data,{parseBlocks:h}=qt(),u=h(a.blocks,a.states,a.positions);Yi.value=u;break}case os.Chunks:{const a=o.data,{parseChunk:h}=qt(),u=a.chunks.map(c=>{const l=h(c.blocks,c.states,c.chunk);return{chunk:c.chunk,blocks:l}});Xi.value=u;break}default:console.warn(`Unknown message: ${JSON.stringify(o)}`)}}function r(o){const a={type:Ys.GetChunks,data:{chunks:o}},{send:h}=_n();h(a)}return{state:As,connect:n,requestChunks:r,blocksMsg:Yi,chunksMsg:Xi}}const Ct=12;function wn(){function n(r){return`${r.x},${r.y},${r.z}:${r.size}`}function t(r,o){if(r.size!=o.size)throw"Can't compare distance of chunks of different size.";const a=r.size,h=Math.abs(r.x/a-o.x/a),u=Math.abs(r.y/a-o.y/a),c=Math.abs(r.z/a-o.z/a);return Math.max(h,Math.max(u,c))}function e(r){return{x:Math.floor(r.x/Ct)*Ct,y:Math.floor(r.y/Ct)*Ct,z:Math.floor(r.z/Ct)*Ct,size:Ct}}function s(r,o,a,h){const u=e(r);return e({x:u.x+Ct*o,y:u.y+Ct*a,z:u.z+Ct*h})}function i(r,o=1,a=!1){const h=[];for(let u=-o;u<=o;++u)for(let c=-o;c<=o;++c)for(let l=-o;l<=o;++l){if(a&&u==0&&c==0&&l==0)continue;const d=s(r,u,c,l);h.push(d)}return h}return{getId:n,getChunk:e,getNeighboringChunk:s,getChunksAround:i,distance:t}}/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Vi="161",Hi=300,ji=1e3,vs=1001,Zi=1002,Cs=1003,Uo=1006,Lo=1008,No=1009,qo=1014,$o=1015,Go=1020,Do=1023,bn=1026,Ji=1027,Yo=3e3,zn=3001,Mn="",An="srgb",Xo=515,Ki=35044,Es=2e3,Qi=2001;class Sn{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const i=this._listeners[t];if(i!==void 0){const r=i.indexOf(e);r!==-1&&i.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const s=this._listeners[t.type];if(s!==void 0){t.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,t);t.target=null}}}const it=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function Is(){const n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(it[n&255]+it[n>>8&255]+it[n>>16&255]+it[n>>24&255]+"-"+it[t&255]+it[t>>8&255]+"-"+it[t>>16&15|64]+it[t>>24&255]+"-"+it[e&63|128]+it[e>>8&255]+"-"+it[e>>16&255]+it[e>>24&255]+it[s&255]+it[s>>8&255]+it[s>>16&255]+it[s>>24&255]).toLowerCase()}function kt(n,t,e){return Math.max(t,Math.min(e,n))}function He(n,t){switch(t.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function pt(n,t){switch(t.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}class Pt{constructor(t=0,e=0){Pt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,i=t.elements;return this.x=i[0]*e+i[3]*s+i[6],this.y=i[1]*e+i[4]*s+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(kt(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),i=Math.sin(e),r=this.x-t.x,o=this.y-t.y;return this.x=r*s-o*i+t.x,this.y=r*i+o*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class _e{constructor(t,e,s,i,r,o,a,h,u){_e.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,s,i,r,o,a,h,u)}set(t,e,s,i,r,o,a,h,u){const c=this.elements;return c[0]=t,c[1]=i,c[2]=a,c[3]=e,c[4]=r,c[5]=h,c[6]=s,c[7]=o,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,o=s[0],a=s[3],h=s[6],u=s[1],c=s[4],l=s[7],d=s[2],p=s[5],f=s[8],m=i[0],b=i[3],w=i[6],S=i[1],x=i[4],y=i[7],g=i[2],_=i[5],M=i[8];return r[0]=o*m+a*S+h*g,r[3]=o*b+a*x+h*_,r[6]=o*w+a*y+h*M,r[1]=u*m+c*S+l*g,r[4]=u*b+c*x+l*_,r[7]=u*w+c*y+l*M,r[2]=d*m+p*S+f*g,r[5]=d*b+p*x+f*_,r[8]=d*w+p*y+f*M,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],o=t[4],a=t[5],h=t[6],u=t[7],c=t[8];return e*o*c-e*a*u-s*r*c+s*a*h+i*r*u-i*o*h}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],o=t[4],a=t[5],h=t[6],u=t[7],c=t[8],l=c*o-a*u,d=a*h-c*r,p=u*r-o*h,f=e*l+s*d+i*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=l*m,t[1]=(i*u-c*s)*m,t[2]=(a*s-i*o)*m,t[3]=d*m,t[4]=(c*e-i*h)*m,t[5]=(i*r-a*e)*m,t[6]=p*m,t[7]=(s*h-u*e)*m,t[8]=(o*e-s*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,i,r,o,a){const h=Math.cos(r),u=Math.sin(r);return this.set(s*h,s*u,-s*(h*o+u*a)+o+t,-i*u,i*h,-i*(-u*o+h*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(vn.makeScale(t,e)),this}rotate(t){return this.premultiply(vn.makeRotation(-t)),this}translate(t,e){return this.premultiply(vn.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<9;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const vn=new _e;function Vo(n){for(let t=n.length-1;t>=0;--t)if(n[t]>=65535)return!0;return!1}function tr(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}const er={};function Rs(n){n in er||(er[n]=!0,console.warn(n))}function Cn(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}let we;class Ho{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{we===void 0&&(we=tr("canvas")),we.width=t.width,we.height=t.height;const s=we.getContext("2d");t instanceof ImageData?s.putImageData(t,0,0):s.drawImage(t,0,0,t.width,t.height),e=we}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=tr("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");s.drawImage(t,0,0,t.width,t.height);const i=s.getImageData(0,0,t.width,t.height),r=i.data;for(let o=0;o<r.length;o++)r[o]=Cn(r[o]/255)*255;return s.putImageData(i,0,0),e}else if(t.data){const e=t.data.slice(0);for(let s=0;s<e.length;s++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[s]=Math.floor(Cn(e[s]/255)*255):e[s]=Cn(e[s]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let jo=0;class Zo{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:jo++}),this.uuid=Is(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?r.push(En(i[o].image)):r.push(En(i[o]))}else r=En(i);s.url=r}return e||(t.images[this.uuid]=s),s}}function En(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Ho.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Jo=0;class Ot extends Sn{constructor(t=Ot.DEFAULT_IMAGE,e=Ot.DEFAULT_MAPPING,s=vs,i=vs,r=Uo,o=Lo,a=Do,h=No,u=Ot.DEFAULT_ANISOTROPY,c=Mn){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Jo++}),this.uuid=Is(),this.name="",this.source=new Zo(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=u,this.format=a,this.internalFormat=null,this.type=h,this.offset=new Pt(0,0),this.repeat=new Pt(1,1),this.center=new Pt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new _e,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof c=="string"?this.colorSpace=c:(Rs("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=c===zn?An:Mn),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Hi)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ji:t.x=t.x-Math.floor(t.x);break;case vs:t.x=t.x<0?0:1;break;case Zi:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ji:t.y=t.y-Math.floor(t.y);break;case vs:t.y=t.y<0?0:1;break;case Zi:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Rs("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===An?zn:Yo}set encoding(t){Rs("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=t===zn?An:Mn}}Ot.DEFAULT_IMAGE=null,Ot.DEFAULT_MAPPING=Hi,Ot.DEFAULT_ANISOTROPY=1;class je{constructor(t=0,e=0,s=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=s,this._w=i}static slerpFlat(t,e,s,i,r,o,a){let h=s[i+0],u=s[i+1],c=s[i+2],l=s[i+3];const d=r[o+0],p=r[o+1],f=r[o+2],m=r[o+3];if(a===0){t[e+0]=h,t[e+1]=u,t[e+2]=c,t[e+3]=l;return}if(a===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(l!==m||h!==d||u!==p||c!==f){let b=1-a;const w=h*d+u*p+c*f+l*m,S=w>=0?1:-1,x=1-w*w;if(x>Number.EPSILON){const g=Math.sqrt(x),_=Math.atan2(g,w*S);b=Math.sin(b*_)/g,a=Math.sin(a*_)/g}const y=a*S;if(h=h*b+d*y,u=u*b+p*y,c=c*b+f*y,l=l*b+m*y,b===1-a){const g=1/Math.sqrt(h*h+u*u+c*c+l*l);h*=g,u*=g,c*=g,l*=g}}t[e]=h,t[e+1]=u,t[e+2]=c,t[e+3]=l}static multiplyQuaternionsFlat(t,e,s,i,r,o){const a=s[i],h=s[i+1],u=s[i+2],c=s[i+3],l=r[o],d=r[o+1],p=r[o+2],f=r[o+3];return t[e]=a*f+c*l+h*p-u*d,t[e+1]=h*f+c*d+u*l-a*p,t[e+2]=u*f+c*p+a*d-h*l,t[e+3]=c*f-a*l-h*d-u*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,i){return this._x=t,this._y=e,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const s=t._x,i=t._y,r=t._z,o=t._order,a=Math.cos,h=Math.sin,u=a(s/2),c=a(i/2),l=a(r/2),d=h(s/2),p=h(i/2),f=h(r/2);switch(o){case"XYZ":this._x=d*c*l+u*p*f,this._y=u*p*l-d*c*f,this._z=u*c*f+d*p*l,this._w=u*c*l-d*p*f;break;case"YXZ":this._x=d*c*l+u*p*f,this._y=u*p*l-d*c*f,this._z=u*c*f-d*p*l,this._w=u*c*l+d*p*f;break;case"ZXY":this._x=d*c*l-u*p*f,this._y=u*p*l+d*c*f,this._z=u*c*f+d*p*l,this._w=u*c*l-d*p*f;break;case"ZYX":this._x=d*c*l-u*p*f,this._y=u*p*l+d*c*f,this._z=u*c*f-d*p*l,this._w=u*c*l+d*p*f;break;case"YZX":this._x=d*c*l+u*p*f,this._y=u*p*l+d*c*f,this._z=u*c*f-d*p*l,this._w=u*c*l-d*p*f;break;case"XZY":this._x=d*c*l-u*p*f,this._y=u*p*l-d*c*f,this._z=u*c*f+d*p*l,this._w=u*c*l+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,i=Math.sin(s);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],i=e[4],r=e[8],o=e[1],a=e[5],h=e[9],u=e[2],c=e[6],l=e[10],d=s+a+l;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(c-h)*p,this._y=(r-u)*p,this._z=(o-i)*p}else if(s>a&&s>l){const p=2*Math.sqrt(1+s-a-l);this._w=(c-h)/p,this._x=.25*p,this._y=(i+o)/p,this._z=(r+u)/p}else if(a>l){const p=2*Math.sqrt(1+a-s-l);this._w=(r-u)/p,this._x=(i+o)/p,this._y=.25*p,this._z=(h+c)/p}else{const p=2*Math.sqrt(1+l-s-a);this._w=(o-i)/p,this._x=(r+u)/p,this._y=(h+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<Number.EPSILON?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(kt(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(s===0)return this;const i=Math.min(1,e/s);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,i=t._y,r=t._z,o=t._w,a=e._x,h=e._y,u=e._z,c=e._w;return this._x=s*c+o*a+i*u-r*h,this._y=i*c+o*h+r*a-s*u,this._z=r*c+o*u+s*h-i*a,this._w=o*c-s*a-i*h-r*u,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const s=this._x,i=this._y,r=this._z,o=this._w;let a=o*t._w+s*t._x+i*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=s,this._y=i,this._z=r,this;const h=1-a*a;if(h<=Number.EPSILON){const p=1-e;return this._w=p*o+e*this._w,this._x=p*s+e*this._x,this._y=p*i+e*this._y,this._z=p*r+e*this._z,this.normalize(),this}const u=Math.sqrt(h),c=Math.atan2(u,a),l=Math.sin((1-e)*c)/u,d=Math.sin(e*c)/u;return this._w=o*l+this._w*d,this._x=s*l+this._x*d,this._y=i*l+this._y*d,this._z=r*l+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,s){return this.copy(t).slerp(e,s)}random(){const t=Math.random(),e=Math.sqrt(1-t),s=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),s*Math.sin(r),s*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class I{constructor(t=0,e=0,s=0){I.prototype.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return s===void 0&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(sr.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(sr.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*s+r[6]*i,this.y=r[1]*e+r[4]*s+r[7]*i,this.z=r[2]*e+r[5]*s+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,i=this.z,r=t.elements,o=1/(r[3]*e+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*i+r[12])*o,this.y=(r[1]*e+r[5]*s+r[9]*i+r[13])*o,this.z=(r[2]*e+r[6]*s+r[10]*i+r[14])*o,this}applyQuaternion(t){const e=this.x,s=this.y,i=this.z,r=t.x,o=t.y,a=t.z,h=t.w,u=2*(o*i-a*s),c=2*(a*e-r*i),l=2*(r*s-o*e);return this.x=e+h*u+o*l-a*c,this.y=s+h*c+a*u-r*l,this.z=i+h*l+r*c-o*u,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*i,this.y=r[1]*e+r[5]*s+r[9]*i,this.z=r[2]*e+r[6]*s+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(t,Math.min(e,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,i=t.y,r=t.z,o=e.x,a=e.y,h=e.z;return this.x=i*h-r*a,this.y=r*o-s*h,this.z=s*a-i*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return In.copy(this).projectOnVector(t),this.sub(In)}reflect(t){return this.sub(In.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(kt(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,i=this.z-t.z;return e*e+s*s+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const i=Math.sin(e)*t;return this.x=i*Math.sin(s),this.y=Math.cos(e)*t,this.z=i*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,s=Math.sqrt(1-t**2);return this.x=s*Math.cos(e),this.y=s*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const In=new I,sr=new je;class Ze{constructor(t=new I(1/0,1/0,1/0),e=new I(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e+=3)this.expandByPoint(At.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,s=t.count;e<s;e++)this.expandByPoint(At.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=At.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(s!==void 0){const r=s.getAttribute("position");if(e===!0&&r!==void 0&&t.isInstancedMesh!==!0)for(let o=0,a=r.count;o<a;o++)t.isMesh===!0?t.getVertexPosition(o,At):At.fromBufferAttribute(r,o),At.applyMatrix4(t.matrixWorld),this.expandByPoint(At);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Bs.copy(t.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Bs.copy(s.boundingBox)),Bs.applyMatrix4(t.matrixWorld),this.union(Bs)}const i=t.children;for(let r=0,o=i.length;r<o;r++)this.expandByObject(i[r],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,At),At.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Je),Ts.subVectors(this.max,Je),be.subVectors(t.a,Je),ze.subVectors(t.b,Je),Me.subVectors(t.c,Je),jt.subVectors(ze,be),Zt.subVectors(Me,ze),ce.subVectors(be,Me);let e=[0,-jt.z,jt.y,0,-Zt.z,Zt.y,0,-ce.z,ce.y,jt.z,0,-jt.x,Zt.z,0,-Zt.x,ce.z,0,-ce.x,-jt.y,jt.x,0,-Zt.y,Zt.x,0,-ce.y,ce.x,0];return!Rn(e,be,ze,Me,Ts)||(e=[1,0,0,0,1,0,0,0,1],!Rn(e,be,ze,Me,Ts))?!1:(ks.crossVectors(jt,Zt),e=[ks.x,ks.y,ks.z],Rn(e,be,ze,Me,Ts))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,At).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(At).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Ft[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Ft[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Ft[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Ft[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Ft[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Ft[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Ft[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Ft[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Ft),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const Ft=[new I,new I,new I,new I,new I,new I,new I,new I],At=new I,Bs=new Ze,be=new I,ze=new I,Me=new I,jt=new I,Zt=new I,ce=new I,Je=new I,Ts=new I,ks=new I,ue=new I;function Rn(n,t,e,s,i){for(let r=0,o=n.length-3;r<=o;r+=3){ue.fromArray(n,r);const a=i.x*Math.abs(ue.x)+i.y*Math.abs(ue.y)+i.z*Math.abs(ue.z),h=t.dot(ue),u=e.dot(ue),c=s.dot(ue);if(Math.max(-Math.max(h,u,c),Math.min(h,u,c))>a)return!1}return!0}const Ko=new Ze,Ke=new I,Bn=new I;class Qo{constructor(t=new I,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;e!==void 0?s.copy(e):Ko.setFromPoints(t).getCenter(s);let i=0;for(let r=0,o=t.length;r<o;r++)i=Math.max(i,s.distanceToSquared(t[r]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Ke.subVectors(t,this.center);const e=Ke.lengthSq();if(e>this.radius*this.radius){const s=Math.sqrt(e),i=(s-this.radius)*.5;this.center.addScaledVector(Ke,i/s),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Bn.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Ke.copy(t.center).add(Bn)),this.expandByPoint(Ke.copy(t.center).sub(Bn))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}class Et{constructor(t,e,s,i,r,o,a,h,u,c,l,d,p,f,m,b){Et.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,s,i,r,o,a,h,u,c,l,d,p,f,m,b)}set(t,e,s,i,r,o,a,h,u,c,l,d,p,f,m,b){const w=this.elements;return w[0]=t,w[4]=e,w[8]=s,w[12]=i,w[1]=r,w[5]=o,w[9]=a,w[13]=h,w[2]=u,w[6]=c,w[10]=l,w[14]=d,w[3]=p,w[7]=f,w[11]=m,w[15]=b,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Et().fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,i=1/Ae.setFromMatrixColumn(t,0).length(),r=1/Ae.setFromMatrixColumn(t,1).length(),o=1/Ae.setFromMatrixColumn(t,2).length();return e[0]=s[0]*i,e[1]=s[1]*i,e[2]=s[2]*i,e[3]=0,e[4]=s[4]*r,e[5]=s[5]*r,e[6]=s[6]*r,e[7]=0,e[8]=s[8]*o,e[9]=s[9]*o,e[10]=s[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,s=t.x,i=t.y,r=t.z,o=Math.cos(s),a=Math.sin(s),h=Math.cos(i),u=Math.sin(i),c=Math.cos(r),l=Math.sin(r);if(t.order==="XYZ"){const d=o*c,p=o*l,f=a*c,m=a*l;e[0]=h*c,e[4]=-h*l,e[8]=u,e[1]=p+f*u,e[5]=d-m*u,e[9]=-a*h,e[2]=m-d*u,e[6]=f+p*u,e[10]=o*h}else if(t.order==="YXZ"){const d=h*c,p=h*l,f=u*c,m=u*l;e[0]=d+m*a,e[4]=f*a-p,e[8]=o*u,e[1]=o*l,e[5]=o*c,e[9]=-a,e[2]=p*a-f,e[6]=m+d*a,e[10]=o*h}else if(t.order==="ZXY"){const d=h*c,p=h*l,f=u*c,m=u*l;e[0]=d-m*a,e[4]=-o*l,e[8]=f+p*a,e[1]=p+f*a,e[5]=o*c,e[9]=m-d*a,e[2]=-o*u,e[6]=a,e[10]=o*h}else if(t.order==="ZYX"){const d=o*c,p=o*l,f=a*c,m=a*l;e[0]=h*c,e[4]=f*u-p,e[8]=d*u+m,e[1]=h*l,e[5]=m*u+d,e[9]=p*u-f,e[2]=-u,e[6]=a*h,e[10]=o*h}else if(t.order==="YZX"){const d=o*h,p=o*u,f=a*h,m=a*u;e[0]=h*c,e[4]=m-d*l,e[8]=f*l+p,e[1]=l,e[5]=o*c,e[9]=-a*c,e[2]=-u*c,e[6]=p*l+f,e[10]=d-m*l}else if(t.order==="XZY"){const d=o*h,p=o*u,f=a*h,m=a*u;e[0]=h*c,e[4]=-l,e[8]=u*c,e[1]=d*l+m,e[5]=o*c,e[9]=p*l-f,e[2]=f*l-p,e[6]=a*c,e[10]=m*l+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(ta,t,ea)}lookAt(t,e,s){const i=this.elements;return yt.subVectors(t,e),yt.lengthSq()===0&&(yt.z=1),yt.normalize(),Jt.crossVectors(s,yt),Jt.lengthSq()===0&&(Math.abs(s.z)===1?yt.x+=1e-4:yt.z+=1e-4,yt.normalize(),Jt.crossVectors(s,yt)),Jt.normalize(),Ps.crossVectors(yt,Jt),i[0]=Jt.x,i[4]=Ps.x,i[8]=yt.x,i[1]=Jt.y,i[5]=Ps.y,i[9]=yt.y,i[2]=Jt.z,i[6]=Ps.z,i[10]=yt.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,i=e.elements,r=this.elements,o=s[0],a=s[4],h=s[8],u=s[12],c=s[1],l=s[5],d=s[9],p=s[13],f=s[2],m=s[6],b=s[10],w=s[14],S=s[3],x=s[7],y=s[11],g=s[15],_=i[0],M=i[4],R=i[8],E=i[12],z=i[1],v=i[5],C=i[9],A=i[13],B=i[2],k=i[6],P=i[10],W=i[14],N=i[3],L=i[7],U=i[11],T=i[15];return r[0]=o*_+a*z+h*B+u*N,r[4]=o*M+a*v+h*k+u*L,r[8]=o*R+a*C+h*P+u*U,r[12]=o*E+a*A+h*W+u*T,r[1]=c*_+l*z+d*B+p*N,r[5]=c*M+l*v+d*k+p*L,r[9]=c*R+l*C+d*P+p*U,r[13]=c*E+l*A+d*W+p*T,r[2]=f*_+m*z+b*B+w*N,r[6]=f*M+m*v+b*k+w*L,r[10]=f*R+m*C+b*P+w*U,r[14]=f*E+m*A+b*W+w*T,r[3]=S*_+x*z+y*B+g*N,r[7]=S*M+x*v+y*k+g*L,r[11]=S*R+x*C+y*P+g*U,r[15]=S*E+x*A+y*W+g*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],i=t[8],r=t[12],o=t[1],a=t[5],h=t[9],u=t[13],c=t[2],l=t[6],d=t[10],p=t[14],f=t[3],m=t[7],b=t[11],w=t[15];return f*(+r*h*l-i*u*l-r*a*d+s*u*d+i*a*p-s*h*p)+m*(+e*h*p-e*u*d+r*o*d-i*o*p+i*u*c-r*h*c)+b*(+e*u*l-e*a*p-r*o*l+s*o*p+r*a*c-s*u*c)+w*(-i*a*c-e*h*l+e*a*d+i*o*l-s*o*d+s*h*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],i=t[2],r=t[3],o=t[4],a=t[5],h=t[6],u=t[7],c=t[8],l=t[9],d=t[10],p=t[11],f=t[12],m=t[13],b=t[14],w=t[15],S=l*b*u-m*d*u+m*h*p-a*b*p-l*h*w+a*d*w,x=f*d*u-c*b*u-f*h*p+o*b*p+c*h*w-o*d*w,y=c*m*u-f*l*u+f*a*p-o*m*p-c*a*w+o*l*w,g=f*l*h-c*m*h-f*a*d+o*m*d+c*a*b-o*l*b,_=e*S+s*x+i*y+r*g;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const M=1/_;return t[0]=S*M,t[1]=(m*d*r-l*b*r-m*i*p+s*b*p+l*i*w-s*d*w)*M,t[2]=(a*b*r-m*h*r+m*i*u-s*b*u-a*i*w+s*h*w)*M,t[3]=(l*h*r-a*d*r-l*i*u+s*d*u+a*i*p-s*h*p)*M,t[4]=x*M,t[5]=(c*b*r-f*d*r+f*i*p-e*b*p-c*i*w+e*d*w)*M,t[6]=(f*h*r-o*b*r-f*i*u+e*b*u+o*i*w-e*h*w)*M,t[7]=(o*d*r-c*h*r+c*i*u-e*d*u-o*i*p+e*h*p)*M,t[8]=y*M,t[9]=(f*l*r-c*m*r-f*s*p+e*m*p+c*s*w-e*l*w)*M,t[10]=(o*m*r-f*a*r+f*s*u-e*m*u-o*s*w+e*a*w)*M,t[11]=(c*a*r-o*l*r-c*s*u+e*l*u+o*s*p-e*a*p)*M,t[12]=g*M,t[13]=(c*m*i-f*l*i+f*s*d-e*m*d-c*s*b+e*l*b)*M,t[14]=(f*a*i-o*m*i-f*s*h+e*m*h+o*s*b-e*a*b)*M,t[15]=(o*l*i-c*a*i+c*s*h-e*l*h-o*s*d+e*a*d)*M,this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}makeTranslation(t,e,s){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),r=1-s,o=t.x,a=t.y,h=t.z,u=r*o,c=r*a;return this.set(u*o+s,u*a-i*h,u*h+i*a,0,u*a+i*h,c*a+s,c*h-i*o,0,u*h-i*a,c*h+i*o,r*h*h+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,r,o){return this.set(1,s,r,0,t,1,o,0,e,i,1,0,0,0,0,1),this}compose(t,e,s){const i=this.elements,r=e._x,o=e._y,a=e._z,h=e._w,u=r+r,c=o+o,l=a+a,d=r*u,p=r*c,f=r*l,m=o*c,b=o*l,w=a*l,S=h*u,x=h*c,y=h*l,g=s.x,_=s.y,M=s.z;return i[0]=(1-(m+w))*g,i[1]=(p+y)*g,i[2]=(f-x)*g,i[3]=0,i[4]=(p-y)*_,i[5]=(1-(d+w))*_,i[6]=(b+S)*_,i[7]=0,i[8]=(f+x)*M,i[9]=(b-S)*M,i[10]=(1-(d+m))*M,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){const i=this.elements;let r=Ae.set(i[0],i[1],i[2]).length();const o=Ae.set(i[4],i[5],i[6]).length(),a=Ae.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],St.copy(this);const u=1/r,c=1/o,l=1/a;return St.elements[0]*=u,St.elements[1]*=u,St.elements[2]*=u,St.elements[4]*=c,St.elements[5]*=c,St.elements[6]*=c,St.elements[8]*=l,St.elements[9]*=l,St.elements[10]*=l,e.setFromRotationMatrix(St),s.x=r,s.y=o,s.z=a,this}makePerspective(t,e,s,i,r,o,a=Es){const h=this.elements,u=2*r/(e-t),c=2*r/(s-i),l=(e+t)/(e-t),d=(s+i)/(s-i);let p,f;if(a===Es)p=-(o+r)/(o-r),f=-2*o*r/(o-r);else if(a===Qi)p=-o/(o-r),f=-o*r/(o-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return h[0]=u,h[4]=0,h[8]=l,h[12]=0,h[1]=0,h[5]=c,h[9]=d,h[13]=0,h[2]=0,h[6]=0,h[10]=p,h[14]=f,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,s,i,r,o,a=Es){const h=this.elements,u=1/(e-t),c=1/(s-i),l=1/(o-r),d=(e+t)*u,p=(s+i)*c;let f,m;if(a===Es)f=(o+r)*l,m=-2*l;else if(a===Qi)f=r*l,m=-1*l;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return h[0]=2*u,h[4]=0,h[8]=0,h[12]=-d,h[1]=0,h[5]=2*c,h[9]=0,h[13]=-p,h[2]=0,h[6]=0,h[10]=m,h[14]=-f,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let i=0;i<16;i++)if(e[i]!==s[i])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}const Ae=new I,St=new Et,ta=new I(0,0,0),ea=new I(1,1,1),Jt=new I,Ps=new I,yt=new I,nr=new Et,ir=new je;class Os{constructor(t=0,e=0,s=0,i=Os.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=s,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,i=this._order){return this._x=t,this._y=e,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const i=t.elements,r=i[0],o=i[4],a=i[8],h=i[1],u=i[5],c=i[9],l=i[2],d=i[6],p=i[10];switch(e){case"XYZ":this._y=Math.asin(kt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-kt(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(h,u)):(this._y=Math.atan2(-l,r),this._z=0);break;case"ZXY":this._x=Math.asin(kt(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-l,p),this._z=Math.atan2(-o,u)):(this._y=0,this._z=Math.atan2(h,r));break;case"ZYX":this._y=Math.asin(-kt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(h,r)):(this._x=0,this._z=Math.atan2(-o,u));break;case"YZX":this._z=Math.asin(kt(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-l,r)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-kt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,s===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return nr.makeRotationFromQuaternion(t),this.setFromRotationMatrix(nr,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return ir.setFromEuler(this),this.setFromQuaternion(ir,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Os.DEFAULT_ORDER="XYZ";class sa{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let na=0;const rr=new I,Se=new je,Wt=new Et,Fs=new I,Qe=new I,ia=new I,ra=new je,or=new I(1,0,0),ar=new I(0,1,0),hr=new I(0,0,1),oa={type:"added"},aa={type:"removed"};class Kt extends Sn{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:na++}),this.uuid=Is(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Kt.DEFAULT_UP.clone();const t=new I,e=new Os,s=new je,i=new I(1,1,1);function r(){s.setFromEuler(e,!1)}function o(){e.setFromQuaternion(s,void 0,!1)}e._onChange(r),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Et},normalMatrix:{value:new _e}}),this.matrix=new Et,this.matrixWorld=new Et,this.matrixAutoUpdate=Kt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Kt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new sa,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Se.setFromAxisAngle(t,e),this.quaternion.multiply(Se),this}rotateOnWorldAxis(t,e){return Se.setFromAxisAngle(t,e),this.quaternion.premultiply(Se),this}rotateX(t){return this.rotateOnAxis(or,t)}rotateY(t){return this.rotateOnAxis(ar,t)}rotateZ(t){return this.rotateOnAxis(hr,t)}translateOnAxis(t,e){return rr.copy(t).applyQuaternion(this.quaternion),this.position.add(rr.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(or,t)}translateY(t){return this.translateOnAxis(ar,t)}translateZ(t){return this.translateOnAxis(hr,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Wt.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?Fs.copy(t):Fs.set(t,e,s);const i=this.parent;this.updateWorldMatrix(!0,!1),Qe.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Wt.lookAt(Qe,Fs,this.up):Wt.lookAt(Fs,Qe,this.up),this.quaternion.setFromRotationMatrix(Wt),i&&(Wt.extractRotation(i.matrixWorld),Se.setFromRotationMatrix(Wt),this.quaternion.premultiply(Se.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(oa)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(aa)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Wt.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Wt.multiply(t.parent.matrixWorld)),t.applyMatrix4(Wt),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,i=this.children.length;s<i;s++){const o=this.children[s].getObjectByProperty(t,e);if(o!==void 0)return o}}getObjectsByProperty(t,e,s=[]){this[t]===e&&s.push(this);const i=this.children;for(let r=0,o=i.length;r<o;r++)i[r].getObjectsByProperty(t,e,s);return s}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qe,t,ia),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Qe,ra,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let s=0,i=e.length;s<i;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,i=e.length;s<i;s++){const r=e[s];(r.matrixWorldAutoUpdate===!0||t===!0)&&r.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const s=this.parent;if(t===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let r=0,o=i.length;r<o;r++){const a=i[r];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=t===void 0||typeof t=="string",s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),i.maxGeometryCount=this._maxGeometryCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(t),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function r(a,h){return a[h.uuid]===void 0&&(a[h.uuid]=h.toJSON(t)),h.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const h=a.shapes;if(Array.isArray(h))for(let u=0,c=h.length;u<c;u++){const l=h[u];r(t.shapes,l)}else r(t.shapes,h)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let h=0,u=this.material.length;h<u;h++)a.push(r(t.materials,this.material[h]));i.material=a}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const h=this.animations[a];i.animations.push(r(t.animations,h))}}if(e){const a=o(t.geometries),h=o(t.materials),u=o(t.textures),c=o(t.images),l=o(t.shapes),d=o(t.skeletons),p=o(t.animations),f=o(t.nodes);a.length>0&&(s.geometries=a),h.length>0&&(s.materials=h),u.length>0&&(s.textures=u),c.length>0&&(s.images=c),l.length>0&&(s.shapes=l),d.length>0&&(s.skeletons=d),p.length>0&&(s.animations=p),f.length>0&&(s.nodes=f)}return s.object=i,s;function o(a){const h=[];for(const u in a){const c=a[u];delete c.metadata,h.push(c)}return h}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let s=0;s<t.children.length;s++){const i=t.children[s];this.add(i.clone())}return this}}Kt.DEFAULT_UP=new I(0,1,0),Kt.DEFAULT_MATRIX_AUTO_UPDATE=!0,Kt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Z=new I,Ws=new Pt;class Qt{constructor(t,e,s=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=s,this.usage=Ki,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=$o,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return Rs("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[s+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,s=this.count;e<s;e++)Ws.fromBufferAttribute(this,e),Ws.applyMatrix3(t),this.setXY(e,Ws.x,Ws.y);else if(this.itemSize===3)for(let e=0,s=this.count;e<s;e++)Z.fromBufferAttribute(this,e),Z.applyMatrix3(t),this.setXYZ(e,Z.x,Z.y,Z.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)Z.fromBufferAttribute(this,e),Z.applyMatrix4(t),this.setXYZ(e,Z.x,Z.y,Z.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)Z.fromBufferAttribute(this,e),Z.applyNormalMatrix(t),this.setXYZ(e,Z.x,Z.y,Z.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)Z.fromBufferAttribute(this,e),Z.transformDirection(t),this.setXYZ(e,Z.x,Z.y,Z.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let s=this.array[t*this.itemSize+e];return this.normalized&&(s=He(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=pt(s,this.array)),this.array[t*this.itemSize+e]=s,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=He(e,this.array)),e}setX(t,e){return this.normalized&&(e=pt(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=He(e,this.array)),e}setY(t,e){return this.normalized&&(e=pt(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=He(e,this.array)),e}setZ(t,e){return this.normalized&&(e=pt(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=He(e,this.array)),e}setW(t,e){return this.normalized&&(e=pt(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=pt(e,this.array),s=pt(s,this.array)),this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,i){return t*=this.itemSize,this.normalized&&(e=pt(e,this.array),s=pt(s,this.array),i=pt(i,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this}setXYZW(t,e,s,i,r){return t*=this.itemSize,this.normalized&&(e=pt(e,this.array),s=pt(s,this.array),i=pt(i,this.array),r=pt(r,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Ki&&(t.usage=this.usage),t}}class ha extends Qt{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class ca extends Qt{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class le extends Qt{constructor(t,e,s){super(new Float32Array(t),e,s)}}let ua=0;const zt=new Et,Tn=new Kt,ve=new I,xt=new Ze,ts=new Ze,Q=new I;class es extends Sn{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:ua++}),this.uuid=Is(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Vo(t)?ca:ha)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new _e().getNormalMatrix(t);s.applyNormalMatrix(r),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return zt.makeRotationFromQuaternion(t),this.applyMatrix4(zt),this}rotateX(t){return zt.makeRotationX(t),this.applyMatrix4(zt),this}rotateY(t){return zt.makeRotationY(t),this.applyMatrix4(zt),this}rotateZ(t){return zt.makeRotationZ(t),this.applyMatrix4(zt),this}translate(t,e,s){return zt.makeTranslation(t,e,s),this.applyMatrix4(zt),this}scale(t,e,s){return zt.makeScale(t,e,s),this.applyMatrix4(zt),this}lookAt(t){return Tn.lookAt(t),Tn.updateMatrix(),this.applyMatrix4(Tn.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ve).negate(),this.translate(ve.x,ve.y,ve.z),this}setFromPoints(t){const e=[];for(let s=0,i=t.length;s<i;s++){const r=t[s];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new le(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ze);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new I(-1/0,-1/0,-1/0),new I(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let s=0,i=e.length;s<i;s++){const r=e[s];xt.setFromBufferAttribute(r),this.morphTargetsRelative?(Q.addVectors(this.boundingBox.min,xt.min),this.boundingBox.expandByPoint(Q),Q.addVectors(this.boundingBox.max,xt.max),this.boundingBox.expandByPoint(Q)):(this.boundingBox.expandByPoint(xt.min),this.boundingBox.expandByPoint(xt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Qo);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new I,1/0);return}if(t){const s=this.boundingSphere.center;if(xt.setFromBufferAttribute(t),e)for(let r=0,o=e.length;r<o;r++){const a=e[r];ts.setFromBufferAttribute(a),this.morphTargetsRelative?(Q.addVectors(xt.min,ts.min),xt.expandByPoint(Q),Q.addVectors(xt.max,ts.max),xt.expandByPoint(Q)):(xt.expandByPoint(ts.min),xt.expandByPoint(ts.max))}xt.getCenter(s);let i=0;for(let r=0,o=t.count;r<o;r++)Q.fromBufferAttribute(t,r),i=Math.max(i,s.distanceToSquared(Q));if(e)for(let r=0,o=e.length;r<o;r++){const a=e[r],h=this.morphTargetsRelative;for(let u=0,c=a.count;u<c;u++)Q.fromBufferAttribute(a,u),h&&(ve.fromBufferAttribute(t,u),Q.add(ve)),i=Math.max(i,s.distanceToSquared(Q))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=t.array,i=e.position.array,r=e.normal.array,o=e.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Qt(new Float32Array(4*a),4));const h=this.getAttribute("tangent").array,u=[],c=[];for(let z=0;z<a;z++)u[z]=new I,c[z]=new I;const l=new I,d=new I,p=new I,f=new Pt,m=new Pt,b=new Pt,w=new I,S=new I;function x(z,v,C){l.fromArray(i,z*3),d.fromArray(i,v*3),p.fromArray(i,C*3),f.fromArray(o,z*2),m.fromArray(o,v*2),b.fromArray(o,C*2),d.sub(l),p.sub(l),m.sub(f),b.sub(f);const A=1/(m.x*b.y-b.x*m.y);isFinite(A)&&(w.copy(d).multiplyScalar(b.y).addScaledVector(p,-m.y).multiplyScalar(A),S.copy(p).multiplyScalar(m.x).addScaledVector(d,-b.x).multiplyScalar(A),u[z].add(w),u[v].add(w),u[C].add(w),c[z].add(S),c[v].add(S),c[C].add(S))}let y=this.groups;y.length===0&&(y=[{start:0,count:s.length}]);for(let z=0,v=y.length;z<v;++z){const C=y[z],A=C.start,B=C.count;for(let k=A,P=A+B;k<P;k+=3)x(s[k+0],s[k+1],s[k+2])}const g=new I,_=new I,M=new I,R=new I;function E(z){M.fromArray(r,z*3),R.copy(M);const v=u[z];g.copy(v),g.sub(M.multiplyScalar(M.dot(v))).normalize(),_.crossVectors(R,v);const A=_.dot(c[z])<0?-1:1;h[z*4]=g.x,h[z*4+1]=g.y,h[z*4+2]=g.z,h[z*4+3]=A}for(let z=0,v=y.length;z<v;++z){const C=y[z],A=C.start,B=C.count;for(let k=A,P=A+B;k<P;k+=3)E(s[k+0]),E(s[k+1]),E(s[k+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Qt(new Float32Array(e.count*3),3),this.setAttribute("normal",s);else for(let d=0,p=s.count;d<p;d++)s.setXYZ(d,0,0,0);const i=new I,r=new I,o=new I,a=new I,h=new I,u=new I,c=new I,l=new I;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),b=t.getX(d+2);i.fromBufferAttribute(e,f),r.fromBufferAttribute(e,m),o.fromBufferAttribute(e,b),c.subVectors(o,r),l.subVectors(i,r),c.cross(l),a.fromBufferAttribute(s,f),h.fromBufferAttribute(s,m),u.fromBufferAttribute(s,b),a.add(c),h.add(c),u.add(c),s.setXYZ(f,a.x,a.y,a.z),s.setXYZ(m,h.x,h.y,h.z),s.setXYZ(b,u.x,u.y,u.z)}else for(let d=0,p=e.count;d<p;d+=3)i.fromBufferAttribute(e,d+0),r.fromBufferAttribute(e,d+1),o.fromBufferAttribute(e,d+2),c.subVectors(o,r),l.subVectors(i,r),c.cross(l),s.setXYZ(d+0,c.x,c.y,c.z),s.setXYZ(d+1,c.x,c.y,c.z),s.setXYZ(d+2,c.x,c.y,c.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)Q.fromBufferAttribute(t,e),Q.normalize(),t.setXYZ(e,Q.x,Q.y,Q.z)}toNonIndexed(){function t(a,h){const u=a.array,c=a.itemSize,l=a.normalized,d=new u.constructor(h.length*c);let p=0,f=0;for(let m=0,b=h.length;m<b;m++){a.isInterleavedBufferAttribute?p=h[m]*a.data.stride+a.offset:p=h[m]*c;for(let w=0;w<c;w++)d[f++]=u[p++]}return new Qt(d,c,l)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new es,s=this.index.array,i=this.attributes;for(const a in i){const h=i[a],u=t(h,s);e.setAttribute(a,u)}const r=this.morphAttributes;for(const a in r){const h=[],u=r[a];for(let c=0,l=u.length;c<l;c++){const d=u[c],p=t(d,s);h.push(p)}e.morphAttributes[a]=h}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,h=o.length;a<h;a++){const u=o[a];e.addGroup(u.start,u.count,u.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const h=this.parameters;for(const u in h)h[u]!==void 0&&(t[u]=h[u]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const h in s){const u=s[h];t.data.attributes[h]=u.toJSON(t.data)}const i={};let r=!1;for(const h in this.morphAttributes){const u=this.morphAttributes[h],c=[];for(let l=0,d=u.length;l<d;l++){const p=u[l];c.push(p.toJSON(t.data))}c.length>0&&(i[h]=c,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;s!==null&&this.setIndex(s.clone(e));const i=t.attributes;for(const u in i){const c=i[u];this.setAttribute(u,c.clone(e))}const r=t.morphAttributes;for(const u in r){const c=[],l=r[u];for(let d=0,p=l.length;d<p;d++)c.push(l[d].clone(e));this.morphAttributes[u]=c}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let u=0,c=o.length;u<c;u++){const l=o[u];this.addGroup(l.start,l.count,l.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const h=t.boundingSphere;return h!==null&&(this.boundingSphere=h.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}class kn extends es{constructor(t=1,e=1,s=1,i=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:s,widthSegments:i,heightSegments:r,depthSegments:o};const a=this;i=Math.floor(i),r=Math.floor(r),o=Math.floor(o);const h=[],u=[],c=[],l=[];let d=0,p=0;f("z","y","x",-1,-1,s,e,t,o,r,0),f("z","y","x",1,-1,s,e,-t,o,r,1),f("x","z","y",1,1,t,s,e,i,o,2),f("x","z","y",1,-1,t,s,-e,i,o,3),f("x","y","z",1,-1,t,e,s,i,r,4),f("x","y","z",-1,-1,t,e,-s,i,r,5),this.setIndex(h),this.setAttribute("position",new le(u,3)),this.setAttribute("normal",new le(c,3)),this.setAttribute("uv",new le(l,2));function f(m,b,w,S,x,y,g,_,M,R,E){const z=y/M,v=g/R,C=y/2,A=g/2,B=_/2,k=M+1,P=R+1;let W=0,N=0;const L=new I;for(let U=0;U<P;U++){const T=U*v-A;for(let K=0;K<k;K++){const X=K*z-C;L[m]=X*S,L[b]=T*x,L[w]=B,u.push(L.x,L.y,L.z),L[m]=0,L[b]=0,L[w]=_>0?1:-1,c.push(L.x,L.y,L.z),l.push(K/M),l.push(1-U/R),W+=1}}for(let U=0;U<R;U++)for(let T=0;T<M;T++){const K=d+T+k*U,X=d+T+k*(U+1),tt=d+(T+1)+k*(U+1),H=d+(T+1)+k*U;h.push(K,X,H),h.push(X,tt,H),N+=6}a.addGroup(p,N,E),p+=N,d+=W}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new kn(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}class la extends Ot{constructor(t,e,s,i,r,o,a,h,u,c){if(c=c!==void 0?c:bn,c!==bn&&c!==Ji)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&c===bn&&(s=qo),s===void 0&&c===Ji&&(s=Go),super(null,i,r,o,a,h,c,s,u),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=a!==void 0?a:Cs,this.minFilter=h!==void 0?h:Cs,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}const da=new la(1,1);da.compareFunction=Xo;class fa extends Ot{constructor(t,e,s,i,r,o,a,h,u){super(t,e,s,i,r,o,a,h,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Vi}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Vi);function gt(){const n={position:{type:Float32Array,size:3},normal:{type:Float32Array,size:3},uv:{type:Float32Array,size:2},offset:{type:Float32Array,size:3},color:{type:Float32Array,size:4},tintColor:{type:Float32Array,size:3},textureId:{type:Uint16Array,size:1}},t=["position","normal","uv","offset","color","tintColor","textureId"],e=["position","normal","uv","offset","color"];function s(c,l,d){const p=new es;return c.forEach(f=>{const m=n[f].type,b=n[f].size,w=new m(b*l);p.setAttribute(f,new Qt(w,b)),d&&d[f]&&w.set(d[f])}),p}function i(c,l){const d=new es;c=c||1,l=l||1;const p=c/2,f=l/2,m=Math.floor(1)||1,b=Math.floor(1)||1,w=m+1,S=b+1,x=c/m,y=l/b;let g,_;const M=[],R=[],E=[],z=[];for(_=0;_<S;_++){const v=_*y-f;for(g=0;g<w;g++){const C=g*x-p;R.push(C,-v,0),E.push(0,0,1),z.push(g/m),z.push(1-_/b)}}for(_=0;_<b;_++)for(g=0;g<m;g++){const v=g+w*_,C=g+w*(_+1),A=g+1+w*(_+1),B=g+1+w*_;M.push(v,C,B),M.push(C,A,B)}return d.setIndex(M),h(d,"position",new le(R,3)),h(d,"normal",new le(E,3)),h(d,"uv",new le(z,2)),d}function r(c,l){for(const d in l){const p=n[d].type,f=n[d].size,m=new p(l[d].buffer);c.setAttribute(d,new Qt(m,f))}return c}function o(c,l){const d={attributes:{},vertexCount:c.vertex,indexCount:c.index};for(const p in l){const f=n[p].type,m=n[p].size;d.attributes[p]=new f(l[p].array.buffer,0,m*c.vertex)}return d}function a(c,l,d){if(!(l&&l.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",l);return}d===void 0&&(d=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const p=c.attributes;for(const f in p){if(l.attributes[f]===void 0)continue;const b=p[f].array,w=l.attributes[f],S=w.array,x=w.itemSize;for(let y=0,g=x*d;y<S.length;y++,g++)b[g]=S[y]}return c}function h(c,l,d){return l==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),c.setIndex(d),c):(c.attributes[l]=d,c)}function u(c,l,d,p){for(const f in l)if(f in c.attributes){const m=c.attributes[f];m.array.set(l[f]),d&&(m.needsUpdate=!0)}p!=-1&&c.setDrawRange(0,p)}return{createGeometry:s,createPlane:i,setAttributeBuffers:r,getAttributes:o,attributesBlockTextured:t,attributesBlock:e,mergeGeometries:a,addAttribute:h,setGeometryAttributes:u}}class pa{constructor(t,e,s,i,r,o){qe(this,"sizeX");qe(this,"sizeY");qe(this,"sizeZ");qe(this,"sizeXY");qe(this,"maxBlocks");this.minX=t,this.minY=e,this.minZ=s,this.maxX=i,this.maxY=r,this.maxZ=o,this.sizeX=i-t+1,this.sizeY=r-e+1,this.sizeZ=o-s+1,this.maxBlocks=this.sizeX*this.sizeY*this.sizeZ,this.sizeXY=this.sizeX*this.sizeY,this.maxBlocks=this.sizeX*this.sizeY*this.sizeZ}inside(t){return t.x>=this.minX&&t.x<=this.maxX&&t.y>=this.minY&&t.y<=this.maxY&&t.z>=this.minZ&&t.z<=this.maxZ}boundsPos(t){return{x:t.x-this.minX,y:t.y-this.minY,z:t.z-this.minZ}}posIdx(t){const e=this.boundsPos(t);return e.x+this.sizeX*e.y+this.sizeXY*e.z}xyzIdx(t,e,s){const i=this.boundsPos({x:t,y:e,z:s});return i.x+this.sizeX*i.y+this.sizeXY*i.z}boundsPosIdx(t){return t.x+this.sizeX*t.y+this.sizeXY*t.z}}var D=(n=>(n.Model="model",n.Translucent="translucent",n.Liquid="liquid",n.Wireframe="wireframe",n))(D||{}),cr=(n=>(n[n.north=0]="north",n[n.east=1]="east",n[n.south=2]="south",n[n.west=3]="west",n[n.down=4]="down",n[n.up=5]="up",n))(cr||{});const ss=16*16*16*3*3*3;let mt,Ut=[],Y,Us,Pn,ur;const Lt=new Map,Nt=new Map;let Ls={},Ns=[];function Ce(){function n(){Y=new Uint16Array(ss),Us=new Uint8Array(ss),Pn=h(),ur=h(!1,!0),r(),u()}function t(x){const y=Number.MAX_SAFE_INTEGER,g=Number.MIN_SAFE_INTEGER,_=x.reduce((C,A)=>A.x<C?A.x:C,y),M=x.reduce((C,A)=>A.y<C?A.y:C,y),R=x.reduce((C,A)=>A.z<C?A.z:C,y),E=x.reduce((C,A)=>A.x>C?A.x:C,g),z=x.reduce((C,A)=>A.y>C?A.y:C,g),v=x.reduce((C,A)=>A.z>C?A.z:C,g);return new pa(_,M,R,E,z,v)}function e(x){mt=t(x),Ut=x,Ut.length>ss&&console.warn(`[Worker][WorldMesh] Blocks overflow buffer! ${Ut.length} out of ${ss}`),w(),S()}function s(x){Ls=x}function i(x,y){const{setModelGeometries:g,setBlocks:_}=Ce();_(x),g(y),b()}function r(){const{createGeometry:x,attributesBlock:y,attributesBlockTextured:g}=gt(),_=24*ss;Lt.set(D.Model,x(g,_)),Lt.set(D.Translucent,x(g,_)),Lt.set(D.Liquid,x(y,_)),Lt.set(D.Wireframe,x(y,_)),Nt.set(D.Model,{vertex:0,index:0}),Nt.set(D.Translucent,{vertex:0,index:0}),Nt.set(D.Liquid,{vertex:0,index:0}),Nt.set(D.Wireframe,{vertex:0,index:0})}function o(){const{getAttributes:x}=gt(),y={},g=[D.Liquid,D.Model,D.Translucent,D.Wireframe];for(const _ of g){const M=Nt.get(_),R=Lt.get(_).attributes;y[_]=x(M,R)}return y}function a(x){const{setAttributeBuffers:y}=gt(),g=[D.Liquid,D.Model,D.Translucent,D.Wireframe];for(const _ of g){const M=Nt.get(_),R=Lt.get(_),E=x[_].attributes;for(const z in E)E[z].fill(0);y(R,E),M.index=M.vertex=0}}function h(x=!1,y=!1){const{createGeometry:g}=gt(),_=g(["position","normal","uv"],4,{position:y?[.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,-.5,.5]:[-.5,.5,.5,.5,.5,.5,-.5,-.5,.5,.5,-.5,.5],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,0,1,0,0,1,1,1]}),M=_.clone().rotateX(3*Math.PI/2);return x&&M.translate(0,-.125,0),[_.clone().rotateY(Math.PI),_.clone().rotateY(Math.PI/2),_,_.clone().rotateY(3*Math.PI/2),_.clone().rotateX(Math.PI/2),M]}function u(){Ns=[];const x=[{u:"x",us:1,v:"y",vs:1},{u:"z",us:1,v:"y",vs:1},{u:"x",us:-1,v:"y",vs:1},{u:"z",us:-1,v:"y",vs:1},{u:"x",us:-1,v:"z",vs:1},{u:"x",us:-1,v:"z",vs:-1}],y=[{iu:1,iv:1},{iu:-1,iv:1},{iu:1,iv:-1},{iu:-1,iv:-1}];x.forEach((g,_)=>{Ns[_]=[],y.forEach(M=>{const R={x:0,y:0,z:0},E={x:0,y:0,z:0},z={x:0,y:0,z:0};R[g.u]+=M.iu*g.us,E[g.v]+=M.iv*g.vs,z[g.u]+=M.iu*g.us,z[g.v]+=M.iv*g.vs,Ns[_].push([R,E,z])})})}function c(x,y,g,_,M){const R=[{x:0,y:0,z:-1},{x:1,y:0,z:0},{x:0,y:0,z:1},{x:-1,y:0,z:0},{x:0,y:-1,z:0},{x:0,y:1,z:0}],E=Ns[_][M],z=R[_];if(z.x+=x,z.y+=y,z.z+=g,!mt.inside(z))return 4;const v={x:z.x+E[0].x,y:z.y+E[0].y,z:z.z+E[0].z},C={x:z.x+E[1].x,y:z.y+E[1].y,z:z.z+E[1].z},A={x:z.x+E[2].x,y:z.y+E[2].y,z:z.z+E[2].z},B=mt.inside(v)?mt.posIdx(v):-1,k=mt.inside(v)?mt.posIdx(C):-1,P=mt.inside(v)?mt.posIdx(A):-1,W=B!=-1&&Y[B]&64?1:0,N=k!=-1&&Y[k]&64?1:0,L=P!=-1&&Y[P]&64?1:0;return W&&N?0:4-(W+N+L)}function l(x,y,g,_){const{mergeGeometries:M}=gt(),R=x.pos.x,E=x.pos.y,z=x.pos.z,v=x.color>>16&255,C=x.color>>8&255,A=x.color&255,B=x.tintColor>>16&255,k=x.tintColor>>8&255,P=x.tintColor&255,W=g.attributes.offset.array,N=g.attributes.color.array,L=g.attributes.tintColor.array,U=g.attributes.textureId.array;let T=_.vertex,K=_.index;for(let X=0;X<6;++X,T+=4,K+=6){if(!(y&1<<X))continue;const tt=[.2,.2,.6,.8,1],H=[1,3,0,2],ct=[];for(let $=0;$<4;++$)ct[$]=c(R,E,z,X,$);const _t=ct[0]+ct[3]>ct[1]+ct[2];M(g,_t?ur[X]:Pn[X],T);for(let $=0,ut=T,j=3*T,O=4*T;$<4;++$,ut+=1,j+=3,O+=4){W[j]=R,W[j+1]=E,W[j+2]=z;const Re=ct[_t?H[$]:$];N[O]=v*tt[Re],N[O+1]=C*tt[Re],N[O+2]=A*tt[Re],N[O+3]=255,L[j]=B,L[j+1]=k,L[j+2]=P,U[ut]=0}}_.vertex=T,_.index=K}function d(x,y,g,_){const{mergeGeometries:M}=gt();let R=_.vertex,E=_.index;const z=g.attributes.offset.array,v=g.attributes.tintColor.array;let C=x.pos.x;const A=x.pos.y;let B=x.pos.z;if(x.name=="minecraft:tallgrass"){const W=Math.abs(C*17+A*11+B*31),N=W%61/60,L=7*W%43/42;C+=.3*(-1+2*N),B+=.3*(-1+2*L)}const k=x.state,P=Ls[k];for(const W in P){const N=cr[W];if(W!="none"&&!(y>>N&1))continue;const L=P[W],U=L.attributes.position.count;if(U==0)continue;const T=[.2,.2,.4,.7,1],K=[],X=x.isOpaqueCube;if(X&&typeof N<"u")for(let H=0;H<4;++H)K[H]=c(x.pos.x,x.pos.y,x.pos.z,N,H);const tt=U/4;M(g,L,R);for(let H=0;H<tt;++H,E+=6,R+=4){const ct=3*R;for(let _t=0;_t<4;++_t){const $=ct+_t*3;if(z[$]=C,z[$+1]=A,z[$+2]=B,X){const ut=v[$]+v[$+1]+v[$+2]!=0,j=K[_t];ut?(v[$]*=T[j],v[$+1]*=T[j],v[$+2]*=T[j]):(v[$]=255*T[j],v[$+1]=255*T[j],v[$+2]=255*T[j])}}}}_.vertex=R,_.index=E}function p(x,y,g,_){const{mergeGeometries:M}=gt(),R=x.pos.x,E=x.pos.y,z=x.pos.z,v=x.color>>16&255,C=x.color>>8&255,A=x.color&255,B=g.attributes.offset.array,k=g.attributes.color.array;let P=_.vertex,W=_.index;for(let N=0;N<6;++N,P+=4,W+=6)if(y&1<<N){M(g,Pn[N],P);for(let L=0,U=3*P,T=4*P;L<4;++L,U+=3,T+=4)B[U]=R,B[U+1]=E,B[U+2]=z,k[T]=v,k[T+1]=C,k[T+2]=A,k[T+3]=128}_.vertex=P,_.index=W}function f(x,y,g){const{mergeGeometries:_}=gt();let M=g.vertex,R=g.index;const E=new kn(.999,.999,.999),z=y.attributes.offset.array,v=y.attributes.color.array,C=x.pos;_(y,E,M);for(let A=0;A<6;++A,M+=4,R+=6)for(let B=0,k=3*M,P=4*M;B<4;++B,k+=3,P+=4)v[P]=x.color>>16&255,v[P+1]=x.color>>8&255,v[P+2]=x.color&255,v[P+3]=255,z[k]=C.x,z[k+1]=C.y,z[k+2]=C.z;g.vertex=M,g.index=R}function m(x){return x.name=="minecraft:seagrass"||x.name=="minecraft:tall_seagrass"||x.name=="minecraft:tall_seagrass[half=lower]"||x.name=="minecraft:tall_seagrass[half=upper]"}function b(){console.time("[Profile] [WebGL Worker] Update world blocks meshes");for(let x=0;x<Ut.length;++x){const y=Ut[x],g=mt.posIdx(y.pos),_=Us[g],M=y.state,R=y.name=="minecraft:stained_glass",E=Lt.get(R?D.Translucent:D.Model),z=Nt.get(R?D.Translucent:D.Model),v=Lt.get(D.Liquid),C=Nt.get(D.Liquid);if(m(y))M in Ls&&d(y,_,E,z),p(y,_,v,C);else if(_)if(y.isLiquid)p(y,_,v,C);else if(M in Ls)d(y,_,E,z);else if(y.isFull)l(y,_,E,z);else{if(y.isAir||!y.blocksMovement)continue;const A=Lt.get(D.Wireframe),B=Nt.get(D.Wireframe);f(y,A,B)}else continue}console.timeEnd("[Profile] [WebGL Worker] Update world blocks meshes")}function w(){console.time("[Profile] [WebGL Worker] Prepare block info"),Y.fill(0);for(let x=0;x<Ut.length;++x){const y=Ut[x],g=mt.posIdx(y.pos);Y[g]+=y.meta&15,y.isAir&&(Y[g]+=32),y.isOpaqueCube&&(Y[g]+=64),y.isLiquid&&(Y[g]+=128),y.name=="minecraft:glass"&&(Y[g]+=256),y.name=="minecraft:stained_glass"&&(Y[g]+=512),m(y)&&(Y[g]+=1024)}console.timeEnd("[Profile] [WebGL Worker] Prepare block info")}function S(){console.time("[Profile] [WebGL Worker] Calculate faces");for(let x=0;x<Ut.length;++x){const y=Ut[x];let g=0;const _=mt.posIdx(y.pos),M=[{x:y.pos.x,y:y.pos.y,z:y.pos.z-1},{x:y.pos.x+1,y:y.pos.y,z:y.pos.z},{x:y.pos.x,y:y.pos.y,z:y.pos.z+1},{x:y.pos.x-1,y:y.pos.y,z:y.pos.z},{x:y.pos.x,y:y.pos.y-1,z:y.pos.z},{x:y.pos.x,y:y.pos.y+1,z:y.pos.z}],R=(Y[_]&32)!=0,E=(Y[_]&128)!=0,z=(Y[_]&256)!=0,v=(Y[_]&512)!=0,C=(Y[_]&1024)!=0;if(R){Us[_]=0;continue}for(let A=0;A<6;++A){if(!mt.inside(M[A]))continue;const B=mt.posIdx(M[A]),k=Y[B]&15;Y[B]&32;const P=(Y[B]&64)!=0,W=(Y[B]&128)!=0,N=(Y[B]&256)!=0,L=(Y[B]&512)!=0,U=(Y[B]&1024)!=0;let T=P;T=T||E&&(W||U),T=T||C&&(W||U),T=T||z&&N,T=T||v&&L&&y.meta==k,T||(g=g|1<<A)}for(let A=0;A<6;++A){const B=M[A];mt.inside(B)||(g=g|1<<A)}Us[_]=g}console.timeEnd("[Profile] [WebGL Worker] Calculate faces")}return{init:n,setBlocks:e,setModelGeometries:s,rebuild:i,getArrays:o,setArrays:a}}let On=0;function lr(){function n(){++On,console.time(`[Profile] [WebGL Worker] Post geometry (#${On})`);const{getArrays:t}=Ce(),e=t(),s={type:wt.worldGeometry,geometries:e},i=[];for(const o in e){const a=e[o].attributes;for(const h in a){const u=a[h];i.push(u.buffer)}}postMessage(s,i);const{setArraysTransferred:r}=is();r(!0),console.timeEnd(`[Profile] [WebGL Worker] Post geometry (#${On})`)}return{postWorldGeometry:n}}function ns(n){const t=n.type.substring(0,n.type.indexOf(":")),e=n.type.indexOf("[")==-1?n.type.substring(n.type.indexOf(":")+1):n.type.substring(n.type.indexOf(":")+1,n.type.indexOf("[")),s=n.type.indexOf("[")==-1?n.type:n.type.substring(0,n.type.indexOf("[")),i=n.type.indexOf("[")==-1?"":n.type.substring(n.type.indexOf("[")+1,n.type.indexOf("]")),r=i.split(",").filter(a=>!a.startsWith("waterlogged=")).filter(a=>!a.startsWith("powered=")).filter(a=>!a.startsWith("distance=")).filter(a=>!a.startsWith("persistent=")).filter(a=>!a.startsWith("level=")).filter(a=>!a.startsWith("occupied=")).join(","),o={};return i.split(",").forEach(a=>{const[h,u]=a.split("=");o[h]=u}),{domain:t,name:e,fullname:s,variant:r,rawVariant:i,variantList:o}}function ma(){function n(t){return t.map(e=>{const{fullname:s}=ns(e);return{x:e.x,y:e.y,z:e.z,type:e.type,color:e.color,tintColor:e.tintColor||e.color,pos:{x:e.x,y:e.y,z:e.z},name:s,state:e.type,isOpaqueCube:e.isOccluding,isLiquid:e.isLiquid,isFull:!1,isAir:e.isAir,blocksMovement:!1,posIdx:`${e.x},${e.y},${e.z}`,meta:0,isOccluding:e.isOccluding}}).filter(e=>!e.isAir)}return{prepareBlocks:n}}const ht={width:32,height:32,count:0,x:32,y:32};let de,qs;const dr=nt(0),Fn=nt(0);function ya(){function n(){const a=document.createElement("canvas");a.width=ht.x*ht.width*2,a.height=ht.y*ht.height*2;const h=a.getContext("2d");if(!h)throw"Could not initialize 2d context for atlas drawing.";h.clearRect(0,0,a.width,a.height);const u=new fa(a);u.flipY=!1,u.magFilter=Cs,u.minFilter=Cs,u.generateMipmaps=!1,de=h,qs=u}function t(){qs.dispose()}async function e(a){return dr.value+=1,new Promise((h,u)=>{const c=new Image;c.src=a,c.addEventListener("load",()=>{const l=ht.width,d=ht.height,p=l/2,f=d/2,m=l*2,b=d*2;let w=c.width,S=c.height;w!=S&&(w=Math.min(w,S),S=w);const x=document.createElement("canvas");x.width=w,x.height=S;const y=x.getContext("2d");if(!y)throw"Could not initialize 2d context for atlas drawing.";const g=ht.count+1,_=Math.ceil(Math.log(Math.max(32,Math.max(w,S))/32)*Math.LOG2E),M=(v,C,A,B)=>{const k=ht.count+1,P=k%ht.x,W=Math.floor(k/ht.x);de.imageSmoothingEnabled=!1,y.clearRect(0,0,w,S),y.drawImage(c,0,0),de.drawImage(x,v,C,A,B,P*m+p,W*b+f,l,d),y.clearRect(0,0,w,S),y.save(),y.scale(1,-1),y.drawImage(c,0,0,w,-S),y.restore(),de.drawImage(x,v,S-C-B/2,A,B/2,P*m+p,W*b,l,f),de.drawImage(x,v,S-C-B,A,B/2,P*m+p,W*b+d+f,l,f),y.clearRect(0,0,w,S),y.save(),y.scale(-1,1),y.drawImage(c,0,0,-w,S),y.restore(),de.drawImage(x,w-v-A/2,C,A/2,B,P*m,W*b+f,p,d),de.drawImage(x,w-v-A,C,A/2,B,P*m+l+p,W*b+f,p,d),++ht.count},R=Math.pow(2,_),E=w/R,z=S/R;for(let v=0,C=0;v<R;++v,C+=z)for(let A=0,B=0;A<R;++A,B+=E)M(B,C,E,z);qs.needsUpdate=!0,h({index:g,sizeFactor:_}),Fn.value+=1},!1),c.addEventListener("error",l=>{u(`The file at "${a}" is not accessible: ${l}`),Fn.value+=1},!1)})}const s=ht.x,i=ht.y,r=ht.x*ht.y;return{init:n,dispose:t,loadTexture:e,x:s,y:i,maxTexCount:r,texture:qs,count:dr,loadedCount:Fn}}const te={blockstate:{},model:{}},rt={blockstate:{},model:{},texture:{},geometry:{}},fr={},Wn={},$s=new Map;function xa(){const{assetsLocation:n}=self.AppConfig;async function t(f){const m=new Request(f),b=await fetch(m);if(!b.ok)throw new Error(`HTTP error! Status: ${b.status}`);return b.json()}async function e(f){return new Promise(m=>{const b=S=>{const{data:x}=S;if(x.type==dt.textureLoaded){const y=x;if(y.location!=f)return;removeEventListener("message",b),m(y.texture)}};addEventListener("message",b);const w={type:wt.loadTexture,location:f};postMessage(w)})}async function s(f){const{domain:m,name:b,fullname:w}=ns(f),S=`${n}${m}/blockstates/${b}.json`,x=te.blockstate[w];if(x)return Promise.resolve(x);if(w in rt.blockstate)return await rt.blockstate[w],te.blockstate[w];const y=t(S).then(g=>{te.blockstate[w]=g}).catch(g=>{throw new Error(`Failed to load blockstate for "${b}": ${g}`)}).finally(()=>{delete rt.blockstate[w]});return rt.blockstate[w]=y,await y,te.blockstate[w]}async function i(f){const m=f.split(":"),b=m.length>1?m[0]:"minecraft",w=m.length>1?m[1]:m[0],S=`${n}${b}/models/${w}.json`,x=te.model[f];if(x)return x;if(f in rt.model)return await rt.model[f],te.model[f];const y=t(S).then(g=>{te.model[f]=g}).catch(g=>{throw new Error(`Failed to load model for "${w}": ${g}`)}).finally(()=>{delete rt.model[f]});return rt.model[f]=y,await y,te.model[f]}async function r(f){const m=f.split(":"),b=m.length>1?m[0]:"minecraft",w=m.length>1?m[1]:m[0],S=`${n}${b}/textures/${w}.png`,x=$s.get(f);if(x)return x;if(f in rt.texture)return await rt.texture[f],$s.get(f);const y=e(S).then(g=>{$s.set(f,g)}).catch(g=>{throw new Error(`Failed to load texture for "${w}": ${g}`)}).finally(()=>{delete rt.texture[f]});return rt.texture[f]=y,await y,$s.get(f)}function o(f,m){if(!f)throw new Error(m)}async function a(f,m){const b=async w=>{const S=await i(w),x={};let y=[];const _=await("parent"in S?b(S.parent):Promise.resolve({textures:{},elements:[]}));if("elements"in S?y=S.elements:"elements"in _&&(y=_.elements),"textures"in _){for(const M in _.textures)x[M]=_.textures[M];for(const M in S.textures)x[M]=S.textures[M]}return{textures:x,elements:y}};return b(f+":"+m)}function h(f){const m={};for(const b in f){let w=f[b];for(;w[0]=="#";){const S=w.substring(1);if(w=f[S],!w)break}m[b]=w}return m}function u(f,m,b){const{maxTexCount:w}=ya(),{createGeometry:S}=gt(),x=b.tintColor||0,y=b.color||0,g="uvlock"in m&&m.uvlock,_=m.y||0,M=Math.log(w)*Math.LOG2E,R=f.elements,E=f.textures,z={none:0,south:0,east:0,north:0,west:0,up:0,down:0};for(let A=0;A<R.length;++A){const B=R[A].faces;for(const k in B){const P=B[k],W="cullface"in P?P.cullface:"none";++z[W]}}const v={};for(const A in z){const B=4*z[A];v[A]=S(["position","normal","uv","color","tintColor","textureId"],B)}const C={none:0,south:0,east:0,north:0,west:0,up:0,down:0};for(let A=0;A<R.length;++A){const B=R[A],k=B.faces,P=B.from,W=B.to,N=B.rotation;let L=255;"shade"in B&&!B.shade&&(L=1);const U=(W[0]-P[0])/16,T=(W[1]-P[1])/16,K=(W[2]-P[2])/16,X=P[0]/16,tt=P[1]/16,H=P[2]/16,ct=1-(X+U),_t=1-(tt+T),$=1-(H+K);for(const ut in k){const j=k[ut];let O=j.uv;if(O)O=O.map(F=>F/16);else switch(ut){case"north":O=[X,_t,1-ct,1-tt];break;case"east":O=[H,_t,1-$,1-tt];break;case"south":O=[X,_t,1-ct,1-tt];break;case"west":O=[H,_t,1-$,1-tt];break;case"up":O=[X,H,1-ct,1-$];break;case"down":O=[X,H,1-ct,1-$];break}const Re=j.texture.substring(1),fe="cullface"in j?j.cullface:"none",va="tintindex"in j,Ca=j.rotation||0,Ea=v[fe].attributes.textureId.array,Ds=v[fe].attributes.color.array,qn=v[fe].attributes.tintColor.array,$n=4*C[fe];if(va)for(let F=0;F<4;++F){const G=3*($n+F);qn[G]=x>>16&255,qn[G+1]=x>>8&255,qn[G+2]=x&255}for(let F=0;F<4;++F){const G=4*($n+F);Ds[G]=y>>16&255,Ds[G+1]=y>>8&255,Ds[G+2]=y&255,Ds[G+3]=L,Ea[$n+F]=E[Re].index+(E[Re].sizeFactor<<M)}const Be=(F,G,It,ne,pe,Fa,_r)=>{const{createPlane:Wa}=gt(),rs=Wa(F,G);_r||rs.rotateY(Math.PI);const Ua=-.5+F*.5+It,La=-.5+G*.5+ne,Na=-.5+pe;return rs.translate(Ua,La,Na),rs.rotateY(-Fa*Math.PI/180),rs.rotateX(_r*Math.PI/180),rs};let lt;switch(ut){case"north":lt=Be(U,T,X,tt,H,0,0);break;case"east":lt=Be(K,T,H,tt,ct,90,0);break;case"south":lt=Be(U,T,ct,tt,$,180,0);break;case"west":lt=Be(K,T,$,tt,X,270,0);break;case"up":lt=Be(U,K,X,$,1-_t,0,-90);break;case"down":lt=Be(U,K,X,H,1-tt,0,90);break}const V=lt.attributes.uv.array,Te=0,ke=1,Pe=2,Oe=3,Fe=4,We=5,Ue=6,Le=7,Ne=(F,G)=>{const It=G*Math.PI/180,ne=[Math.cos(It),Math.sin(It),-Math.sin(It),Math.cos(It)];return[.5+(ne[0]*(F[0]-.5)+ne[1]*(F[1]-.5)),.5+(ne[2]*(F[0]-.5)+ne[3]*(F[1]-.5))]};if(g&&(ut=="up"||ut=="down")){if(_==90){const F=Ne([O[0],O[1]],-90),G=Ne([O[2],O[3]],-90);O[0]=F[1],O[1]=F[0],O[2]=G[1],O[3]=G[0]}else if(_==180){const F=Ne([O[0],O[1]],-180),G=Ne([O[2],O[3]],-180);O[0]=F[0],O[1]=F[1],O[2]=G[0],O[3]=G[1]}else if(_==270){const F=Ne([O[0],O[1]],-270),G=Ne([O[2],O[3]],-270);O[0]=F[1],O[1]=F[0],O[2]=G[1],O[3]=G[0]}}const Ia=O[1];O[1]=O[3],O[3]=Ia;const Ra=O[0],Ba=O[1],Ta=O[2],ka=O[3],se={0:[Te,Fe,We,Le,Pe,Ue,ke,Oe],90:[Te,Pe,ke,We,Fe,Ue,Oe,Le],180:[Pe,Ue,ke,Oe,Te,Fe,We,Le],270:[Fe,Ue,Oe,Le,Te,Pe,ke,We]}[Ca];if(V[se[0]]=V[se[1]]=Ra,V[se[2]]=V[se[3]]=Ba,V[se[4]]=V[se[5]]=Ta,V[se[6]]=V[se[7]]=ka,g&&ut=="down"){let F;F=V[Te],V[Te]=V[Ue],V[Ue]=F,F=V[ke],V[ke]=V[Le],V[Le]=F,F=V[Pe],V[Pe]=V[Fe],V[Fe]=F,F=V[Oe],V[Oe]=V[We],V[We]=F}if(N){const F=N.origin,G=N.angle,It=N.axis,ne=N.rescale;if(F&&lt.translate(.5-F[0]/16,.5-F[1]/16,.5-F[2]/16),It=="x"&&lt.rotateX(G*Math.PI/180),It=="y"&&lt.rotateY(G*Math.PI/180),It=="z"&&lt.rotateZ(G*Math.PI/180),F&&lt.translate(-.5+F[0]/16,-.5+F[1]/16,-.5+F[2]/16),ne){if(ut=="south"||ut=="north"){const pe=1/(U*Math.cos(G*Math.PI/180));lt.scale(pe,1,pe)}else if(ut=="east"||ut=="west"){const pe=1/(K*Math.cos(G*Math.PI/180));lt.scale(pe,1,pe)}}}const Pa=4*C[fe],{mergeGeometries:Oa}=gt();Oa(v[fe],lt,Pa),++C[fe]}}return v}async function c(f,m){const{domain:b}=ns(m),w=f.model.indexOf("/")!==-1?f.model.substring(f.model.indexOf("/")+1):f.model,S=await a(b,"block/"+w);let x=S.textures;if("textures"in f)for(const E in f.textures)x[E]=f.textures[E];x=h(x);const y=Object.keys(x).map(E=>x[E]).filter((E,z,v)=>v.indexOf(E)===z),g=y.map(E=>r(E)),_=await Promise.all(g),M={};for(const E in x){const z=x[E],v=y.indexOf(z);M[E]=_[v]}S.textures=M;let R=u(S,f,m);if("x"in f||"y"in f||"z"in f){const E=f.x||0,z=f.y||0,v=f.z||0,C={0:{north:"north",east:"east",south:"south",west:"west",up:"up",down:"down",none:"none"},90:{north:"down",east:"east",south:"up",west:"west",up:"north",down:"south",none:"none"},180:{north:"south",east:"east",south:"north",west:"west",up:"down",down:"up",none:"none"},270:{north:"up",east:"east",south:"down",west:"west",up:"south",down:"north",none:"none"}},A={0:{north:"north",east:"east",south:"south",west:"west",up:"up",down:"down",none:"none"},90:{north:"east",east:"south",south:"west",west:"north",up:"up",down:"down",none:"none"},180:{north:"south",east:"west",south:"north",west:"east",up:"up",down:"down",none:"none"},270:{north:"west",east:"north",south:"east",west:"south",up:"up",down:"down",none:"none"}},B={0:{north:"north",east:"east",south:"south",west:"west",up:"up",down:"down",none:"none"},90:{north:"north",east:"down",south:"south",west:"up",up:"east",down:"west",none:"none"},180:{north:"north",east:"west",south:"south",west:"east",up:"up",down:"down",none:"none"},270:{north:"north",east:"up",south:"south",west:"down",up:"west",down:"east",none:"none"}},k=C[E],P=A[z],W=B[v],N={};for(const L in R){const U=R[L].clone();let T=k[L];T=P[T],T=W[T],E&&U.rotateX(-E*Math.PI/180),z&&U.rotateY(-z*Math.PI/180),v&&U.rotateZ(-v*Math.PI/180),N[T]=U}R=N}return{model:S,geometries:R}}async function l(f,m){if("variants"in f){o(typeof f.variants<"u");const b=f.variants,{variant:w,variantList:S}=ns(m);let x=b[w];if(!x&&"powered"in S){const g=`${w},powered=${S.powered}`;x=b[g]}x||(x=b[Object.keys(b)[0]],console.warn(`Variant ${w} not found, using default.`,m,b)),Array.isArray(x)&&(x=x[0]);const y=await c(x,m);fr[m.type]=y.model,Wn[m.type]=y.geometries}else if("multipart"in f)await d(f,m);else{console.warn("Blockstate has no variants and is not multipart",m);return}}async function d(f,m){o(typeof f.multipart<"u");const b={},{variant:w}=ns(m);w.split(",").forEach(y=>{const g=y.split("=");b[g[0]]=g[1]});const S=[];if(f.multipart.forEach(y=>{if("when"in y){const g=y.when;("OR"in g?g.OR:[g]).some(R=>{for(const E in R){const z=""+b[E];if(!(""+R[E]).split("|").some(A=>A==z))return!1}return!0})&&S.push(y.apply)}else S.push(y.apply)}),!S.length)throw"Blockstate is multipart, but has no parts.";const x=S.map(y=>c(y,m).catch(g=>{throw g}));Promise.all(x).then(y=>{const g={none:null,south:null,east:null,north:null,west:null,up:null,down:null},_={none:0,south:0,east:0,north:0,west:0,up:0,down:0},{createGeometry:M,attributesBlockTextured:R}=gt();for(const E in g){const z=y.reduce((v,C)=>v+(C?C.geometries[E].attributes.position.count:0),0);g[E]=M(R,z)}y.forEach(E=>{if(E)for(const z in g){const v=g[z],{mergeGeometries:C}=gt();C(v,E.geometries[z],_[z]),_[z]+=E.geometries[z].attributes.position.count}}),Wn[m.type]=g},y=>{throw y})}async function p(f){try{const m=f.type;if(m in fr)return;const b=await s(f);m in rt.geometry?await rt.geometry[m]:(rt.geometry[m]=l(b,f),await rt.geometry[m])}catch(m){console.warn(m)}}return{prepareBlock:p,geometries:Wn}}const Un=nt(!1);let pr=[],mr={};const yr=nt(!1),Gs=nt(0),Ln=nt(0);function is(){async function n(){Gs.value+=1;const s=Gs.value,{blocks:i}=Ie(),{prepareBlocks:r}=ma(),o=r(i.value),{prepareBlock:a,geometries:h}=xa();if(await Promise.all(o.map(l=>a(l))),yr.value){console.warn("[Worker][BlocksChanged] Arrays transfered, pending rebuild."),Un.value=!0,pr=o,mr=h,Ln.value=s;return}const{rebuild:u}=Ce(),{postWorldGeometry:c}=lr();u(o,h),c()}function t(){const{rebuild:s}=Ce(),{postWorldGeometry:i}=lr();if(Un.value){if(console.warn("[Worker][RebuildIfPending] Was pending, rebuild.",Gs.value,Ln.value),Un.value=!1,Gs.value>Ln.value){console.warn("[Worker][RebuildIfPending] Fresh rebuild already running.");return}s(pr,mr),i()}}function e(s){yr.value=s}return{rebuildIfPending:t,blocksChanged:n,setArraysTransferred:e}}const{getId:Ee}=wn(),Nn=new Set,ee=gi([]),ga=xn(()=>ee.value.map(n=>n.chunk)),_a=xn(()=>new Set(ga.value.map(n=>Ee(n)))),wa=xn(()=>ee.value.flatMap(n=>n.blocks));function Ie(){function n(i){const r=i.filter(a=>{const h=Ee(a);return Nn.has(h)?(console.debug("Skipping chunk load: is loading."),!1):_a.value.has(h)?(console.debug("Skipping chunk load: already loaded."),!1):!0});if(r.forEach(a=>{const h=Ee(a);Nn.add(h)}),r.length==0)return;console.debug("Chunks requested",r);const{requestChunks:o}=Ss();o(r)}function t(i,r){Nn.delete(Ee(i)),ee.value=[...ee.value,{chunk:i,blocks:r}]}function e(i){const{getChunk:r}=wn(),o=ee.value;i.forEach(a=>{const h=r({x:a.x,y:a.y,z:a.z}),u=o.find(m=>Ee(m.chunk)==Ee(h));if(!u)return;const c=h.size,l=a.x-h.x,d=a.y-h.y,p=a.z-h.z,f=l*c*c+d*c+p;u.blocks[f]=a}),ee.value=o}function s(i,r){const{getChunk:o,distance:a}=wn(),h=o(i),u=ee.value.filter(l=>a(h,l.chunk)<=r);ee.value=u;const{blocksChanged:c}=is();c()}return{loadChunks:n,addChunk:t,releaseChunks:s,replaceBlocks:e,blocks:wa}}const xr=gi({x:0,y:0,z:0});function gr(){function n(t){xr.value=t}return{centerPos:xr,setPos:n}}function ba(){function n(t){switch(t.type){case dt.config:{const e=t,{type:s,...i}=e;console.log(`[Main -> Worker] Config: ${JSON.stringify(i)})`),self.AppConfig=i;break}case dt.connect:{const e=t;console.log(`[Main -> Worker] Connect: ${e.host}:${e.port} (${e.entityId})`);const{connect:s}=Ss();s(e.host,e.port,e.ssl,e.playerId,e.entityId);break}case dt.centerPos:{const e=t,{setPos:s}=gr();s(e.pos);break}case dt.requestChunks:{const e=t;console.log(`[Main -> Worker] Request chunks: ${JSON.stringify(e.chunks)}`);const{loadChunks:s}=Ie();s(e.chunks);break}case dt.returnGeometryArrays:{const e=t;console.log("[Main -> Worker] Return array geometry");const{setArraysTransferred:s}=is();s(!1);const{setArrays:i}=Ce();i(e.arrays);const{rebuildIfPending:r}=is();r();break}case dt.textureLoaded:break;default:console.log(`[Main -> Worker] Unknown message: "${JSON.stringify(t)}"`)}}return{handle:n}}function za(){const{blocksMsg:n,chunksMsg:t}=Ss();Ht(n,e=>{const{replaceBlocks:s}=Ie();s(e)}),Ht(t,e=>{const{addChunk:s}=Ie();e.forEach(o=>s(o.chunk,o.blocks));const{centerPos:i}=gr(),{releaseChunks:r}=Ie();r(i.value,2)})}const{init:Ma}=Ce();Ma(),onmessage=n=>{const{handle:t}=ba();t(n.data)};const{state:Aa}=Ss();Ht(Aa,n=>{if(n==$i.connected){const t={type:wt.stateReady};postMessage(t)}}),za();const{blocks:Sa}=Ie();Ht(Sa,async()=>{const{blocksChanged:n}=is();n()})})();
